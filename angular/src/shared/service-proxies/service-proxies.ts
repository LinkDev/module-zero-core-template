/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.9.0 (NJsonSchema v9.10.9.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AnnouncementServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<AnnouncementDto> {
        let url_ = this.baseUrl + "/api/services/app/Announcement/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<AnnouncementDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AnnouncementDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<AnnouncementDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AnnouncementDto.fromJS(resultData200) : new AnnouncementDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AnnouncementDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfAnnouncementDto> {
        let url_ = this.baseUrl + "/api/services/app/Announcement/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAnnouncementDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfAnnouncementDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfAnnouncementDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAnnouncementDto.fromJS(resultData200) : new PagedResultDtoOfAnnouncementDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfAnnouncementDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: AnnouncementDto): Observable<AnnouncementDto> {
        let url_ = this.baseUrl + "/api/services/app/Announcement/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<AnnouncementDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AnnouncementDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<AnnouncementDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AnnouncementDto.fromJS(resultData200) : new AnnouncementDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AnnouncementDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: AnnouncementDto): Observable<AnnouncementDto> {
        let url_ = this.baseUrl + "/api/services/app/Announcement/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<AnnouncementDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AnnouncementDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<AnnouncementDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AnnouncementDto.fromJS(resultData200) : new AnnouncementDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AnnouncementDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Announcement/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ApplicationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationDto.fromJS(resultData200) : new ApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicationDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfApplicationDto.fromJS(resultData200) : new PagedResultDtoOfApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfApplicationDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ApplicationDto): Observable<ApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationDto.fromJS(resultData200) : new ApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicationDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ApplicationDto): Observable<ApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationDto.fromJS(resultData200) : new ApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicationDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ApplicationCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ApplicationCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationCategory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ApplicationCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicationCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ApplicationCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationCategoryDto.fromJS(resultData200) : new ApplicationCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicationCategoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfApplicationCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationCategory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApplicationCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfApplicationCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfApplicationCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfApplicationCategoryDto.fromJS(resultData200) : new PagedResultDtoOfApplicationCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfApplicationCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ApplicationCategoryDto): Observable<ApplicationCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ApplicationCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicationCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ApplicationCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationCategoryDto.fromJS(resultData200) : new ApplicationCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicationCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ApplicationCategoryDto): Observable<ApplicationCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ApplicationCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApplicationCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ApplicationCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationCategoryDto.fromJS(resultData200) : new ApplicationCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApplicationCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationCategory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ApprovalRequestServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ApprovalRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequest/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ApprovalRequestDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalRequestDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ApprovalRequestDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalRequestDto.fromJS(resultData200) : new ApprovalRequestDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalRequestDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfApprovalRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequest/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalRequestDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalRequestDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfApprovalRequestDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfApprovalRequestDto.fromJS(resultData200) : new PagedResultDtoOfApprovalRequestDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfApprovalRequestDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ApprovalRequestDto): Observable<ApprovalRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ApprovalRequestDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalRequestDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ApprovalRequestDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalRequestDto.fromJS(resultData200) : new ApprovalRequestDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalRequestDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ApprovalRequestDto): Observable<ApprovalRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequest/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ApprovalRequestDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalRequestDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ApprovalRequestDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalRequestDto.fromJS(resultData200) : new ApprovalRequestDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalRequestDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequest/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ApprovalRequestStepServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ApprovalRequestStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequestStep/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ApprovalRequestStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalRequestStepDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ApprovalRequestStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalRequestStepDto.fromJS(resultData200) : new ApprovalRequestStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalRequestStepDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfApprovalRequestStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequestStep/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalRequestStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalRequestStepDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfApprovalRequestStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfApprovalRequestStepDto.fromJS(resultData200) : new PagedResultDtoOfApprovalRequestStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfApprovalRequestStepDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ApprovalRequestStepDto): Observable<ApprovalRequestStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequestStep/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ApprovalRequestStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalRequestStepDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ApprovalRequestStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalRequestStepDto.fromJS(resultData200) : new ApprovalRequestStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalRequestStepDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ApprovalRequestStepDto): Observable<ApprovalRequestStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequestStep/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ApprovalRequestStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalRequestStepDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ApprovalRequestStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalRequestStepDto.fromJS(resultData200) : new ApprovalRequestStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalRequestStepDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRequestStep/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ApprovalStepServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ApprovalStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalStep/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ApprovalStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalStepDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ApprovalStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalStepDto.fromJS(resultData200) : new ApprovalStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalStepDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfApprovalStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalStep/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApprovalStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfApprovalStepDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfApprovalStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfApprovalStepDto.fromJS(resultData200) : new PagedResultDtoOfApprovalStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfApprovalStepDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ApprovalStepDto): Observable<ApprovalStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalStep/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ApprovalStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalStepDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ApprovalStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalStepDto.fromJS(resultData200) : new ApprovalStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalStepDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ApprovalStepDto): Observable<ApprovalStepDto> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalStep/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ApprovalStepDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ApprovalStepDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ApprovalStepDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApprovalStepDto.fromJS(resultData200) : new ApprovalStepDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ApprovalStepDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalStep/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class AssetTypeServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<AssetTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetType/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<AssetTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AssetTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<AssetTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssetTypeDto.fromJS(resultData200) : new AssetTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AssetTypeDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfAssetTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetType/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfAssetTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAssetTypeDto.fromJS(resultData200) : new PagedResultDtoOfAssetTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfAssetTypeDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: AssetTypeDto): Observable<AssetTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<AssetTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AssetTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<AssetTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssetTypeDto.fromJS(resultData200) : new AssetTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AssetTypeDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: AssetTypeDto): Observable<AssetTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<AssetTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AssetTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<AssetTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssetTypeDto.fromJS(resultData200) : new AssetTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AssetTypeDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetType/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CallBackResponseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<CallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/CallBackResponse/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<CallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<CallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBackResponseDto.fromJS(resultData200) : new CallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CallBackResponseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfCallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/CallBackResponse/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfCallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfCallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCallBackResponseDto.fromJS(resultData200) : new PagedResultDtoOfCallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfCallBackResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: CallBackResponseDto): Observable<CallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/CallBackResponse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<CallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<CallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBackResponseDto.fromJS(resultData200) : new CallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CallBackResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: CallBackResponseDto): Observable<CallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/CallBackResponse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<CallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<CallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CallBackResponseDto.fromJS(resultData200) : new CallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CallBackResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CallBackResponse/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<CommentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommentDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<CommentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDto.fromJS(resultData200) : new CommentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommentDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfCommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCommentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfCommentDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfCommentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCommentDto.fromJS(resultData200) : new PagedResultDtoOfCommentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfCommentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: CommentDto): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<CommentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommentDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<CommentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDto.fromJS(resultData200) : new CommentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: CommentDto): Observable<CommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<CommentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommentDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<CommentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDto.fromJS(resultData200) : new CommentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommentDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeUiTheme(input?: ChangeUiThemeInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeUiTheme(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeUiTheme(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DomainServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<DomainDto> {
        let url_ = this.baseUrl + "/api/services/app/Domain/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainDto.fromJS(resultData200) : new DomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/Domain/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDomainDto.fromJS(resultData200) : new PagedResultDtoOfDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: DomainDto): Observable<DomainDto> {
        let url_ = this.baseUrl + "/api/services/app/Domain/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<DomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainDto.fromJS(resultData200) : new DomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: DomainDto): Observable<DomainDto> {
        let url_ = this.baseUrl + "/api/services/app/Domain/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<DomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainDto.fromJS(resultData200) : new DomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Domain/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DomainGroupServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<DomainGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroup/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DomainGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DomainGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupDto.fromJS(resultData200) : new DomainGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfDomainGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroup/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDomainGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDomainGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfDomainGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDomainGroupDto.fromJS(resultData200) : new PagedResultDtoOfDomainGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDomainGroupDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: DomainGroupDto): Observable<DomainGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<DomainGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DomainGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupDto.fromJS(resultData200) : new DomainGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: DomainGroupDto): Observable<DomainGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroup/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<DomainGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DomainGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupDto.fromJS(resultData200) : new DomainGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroup/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DomainGroupCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<DomainGroupCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupCategory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DomainGroupCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DomainGroupCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupCategoryDto.fromJS(resultData200) : new DomainGroupCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupCategoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfDomainGroupCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupCategory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDomainGroupCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDomainGroupCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfDomainGroupCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDomainGroupCategoryDto.fromJS(resultData200) : new PagedResultDtoOfDomainGroupCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDomainGroupCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: DomainGroupCategoryDto): Observable<DomainGroupCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<DomainGroupCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DomainGroupCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupCategoryDto.fromJS(resultData200) : new DomainGroupCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: DomainGroupCategoryDto): Observable<DomainGroupCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<DomainGroupCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DomainGroupCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupCategoryDto.fromJS(resultData200) : new DomainGroupCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupCategory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DomainGroupSubCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<DomainGroupSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupSubCategory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DomainGroupSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DomainGroupSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupSubCategoryDto.fromJS(resultData200) : new DomainGroupSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupSubCategoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfDomainGroupSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupSubCategory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDomainGroupSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDomainGroupSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfDomainGroupSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDomainGroupSubCategoryDto.fromJS(resultData200) : new PagedResultDtoOfDomainGroupSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDomainGroupSubCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: DomainGroupSubCategoryDto): Observable<DomainGroupSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupSubCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<DomainGroupSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DomainGroupSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupSubCategoryDto.fromJS(resultData200) : new DomainGroupSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupSubCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: DomainGroupSubCategoryDto): Observable<DomainGroupSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupSubCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<DomainGroupSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainGroupSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DomainGroupSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainGroupSubCategoryDto.fromJS(resultData200) : new DomainGroupSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainGroupSubCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DomainGroupSubCategory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DomainSettingServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<DomainSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainSetting/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DomainSettingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainSettingDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DomainSettingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainSettingDto.fromJS(resultData200) : new DomainSettingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainSettingDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfDomainSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainSetting/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDomainSettingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDomainSettingDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfDomainSettingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDomainSettingDto.fromJS(resultData200) : new PagedResultDtoOfDomainSettingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDomainSettingDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: DomainSettingDto): Observable<DomainSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainSetting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<DomainSettingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainSettingDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DomainSettingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainSettingDto.fromJS(resultData200) : new DomainSettingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainSettingDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: DomainSettingDto): Observable<DomainSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<DomainSettingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainSettingDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DomainSettingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainSettingDto.fromJS(resultData200) : new DomainSettingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainSettingDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DomainSetting/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class DomainTrainingCenterServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<DomainTrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainTrainingCenter/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<DomainTrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainTrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<DomainTrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainTrainingCenterDto.fromJS(resultData200) : new DomainTrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainTrainingCenterDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfDomainTrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainTrainingCenter/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDomainTrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDomainTrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfDomainTrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDomainTrainingCenterDto.fromJS(resultData200) : new PagedResultDtoOfDomainTrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDomainTrainingCenterDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: DomainTrainingCenterDto): Observable<DomainTrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainTrainingCenter/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<DomainTrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainTrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DomainTrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainTrainingCenterDto.fromJS(resultData200) : new DomainTrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainTrainingCenterDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: DomainTrainingCenterDto): Observable<DomainTrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/DomainTrainingCenter/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<DomainTrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DomainTrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DomainTrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DomainTrainingCenterDto.fromJS(resultData200) : new DomainTrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DomainTrainingCenterDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DomainTrainingCenter/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class EncodingMapperQuestionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<EncodingMapperQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingMapperQuestion/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<EncodingMapperQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EncodingMapperQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<EncodingMapperQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EncodingMapperQuestionDto.fromJS(resultData200) : new EncodingMapperQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EncodingMapperQuestionDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfEncodingMapperQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingMapperQuestion/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEncodingMapperQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfEncodingMapperQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfEncodingMapperQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEncodingMapperQuestionDto.fromJS(resultData200) : new PagedResultDtoOfEncodingMapperQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfEncodingMapperQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: EncodingMapperQuestionDto): Observable<EncodingMapperQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingMapperQuestion/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<EncodingMapperQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EncodingMapperQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<EncodingMapperQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EncodingMapperQuestionDto.fromJS(resultData200) : new EncodingMapperQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EncodingMapperQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: EncodingMapperQuestionDto): Observable<EncodingMapperQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingMapperQuestion/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<EncodingMapperQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EncodingMapperQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<EncodingMapperQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EncodingMapperQuestionDto.fromJS(resultData200) : new EncodingMapperQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EncodingMapperQuestionDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EncodingMapperQuestion/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class EncodingResponseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<EncodingResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingResponse/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<EncodingResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EncodingResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<EncodingResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EncodingResponseDto.fromJS(resultData200) : new EncodingResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EncodingResponseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfEncodingResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingResponse/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEncodingResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfEncodingResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfEncodingResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEncodingResponseDto.fromJS(resultData200) : new PagedResultDtoOfEncodingResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfEncodingResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: EncodingResponseDto): Observable<EncodingResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingResponse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<EncodingResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EncodingResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<EncodingResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EncodingResponseDto.fromJS(resultData200) : new EncodingResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EncodingResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: EncodingResponseDto): Observable<EncodingResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/EncodingResponse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<EncodingResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EncodingResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<EncodingResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EncodingResponseDto.fromJS(resultData200) : new EncodingResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EncodingResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EncodingResponse/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ExamResultServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ExamResult/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExamResultDto.fromJS(resultData200) : new ExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExamResultDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ExamResult/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfExamResultDto.fromJS(resultData200) : new PagedResultDtoOfExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfExamResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ExamResultDto): Observable<ExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ExamResult/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExamResultDto.fromJS(resultData200) : new ExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExamResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ExamResultDto): Observable<ExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ExamResult/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExamResultDto.fromJS(resultData200) : new ExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExamResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExamResult/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class InspectionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<InspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/Inspection/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<InspectionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<InspectionDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<InspectionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InspectionDto.fromJS(resultData200) : new InspectionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InspectionDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfInspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/Inspection/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfInspectionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfInspectionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfInspectionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfInspectionDto.fromJS(resultData200) : new PagedResultDtoOfInspectionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfInspectionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: InspectionDto): Observable<InspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/Inspection/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<InspectionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<InspectionDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<InspectionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InspectionDto.fromJS(resultData200) : new InspectionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InspectionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: InspectionDto): Observable<InspectionDto> {
        let url_ = this.baseUrl + "/api/services/app/Inspection/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<InspectionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<InspectionDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<InspectionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InspectionDto.fromJS(resultData200) : new InspectionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InspectionDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Inspection/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LocationTrackingServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<LocationTrackingDto> {
        let url_ = this.baseUrl + "/api/services/app/LocationTracking/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<LocationTrackingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LocationTrackingDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<LocationTrackingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationTrackingDto.fromJS(resultData200) : new LocationTrackingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LocationTrackingDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfLocationTrackingDto> {
        let url_ = this.baseUrl + "/api/services/app/LocationTracking/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLocationTrackingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLocationTrackingDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfLocationTrackingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLocationTrackingDto.fromJS(resultData200) : new PagedResultDtoOfLocationTrackingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfLocationTrackingDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: LocationTrackingDto): Observable<LocationTrackingDto> {
        let url_ = this.baseUrl + "/api/services/app/LocationTracking/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<LocationTrackingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LocationTrackingDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<LocationTrackingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationTrackingDto.fromJS(resultData200) : new LocationTrackingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LocationTrackingDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: LocationTrackingDto): Observable<LocationTrackingDto> {
        let url_ = this.baseUrl + "/api/services/app/LocationTracking/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<LocationTrackingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LocationTrackingDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<LocationTrackingDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationTrackingDto.fromJS(resultData200) : new LocationTrackingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LocationTrackingDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LocationTracking/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LogServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<LogDto> {
        let url_ = this.baseUrl + "/api/services/app/Log/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<LogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LogDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<LogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogDto.fromJS(resultData200) : new LogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LogDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfLogDto> {
        let url_ = this.baseUrl + "/api/services/app/Log/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLogDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfLogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLogDto.fromJS(resultData200) : new PagedResultDtoOfLogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfLogDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: LogDto): Observable<LogDto> {
        let url_ = this.baseUrl + "/api/services/app/Log/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<LogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LogDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<LogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogDto.fromJS(resultData200) : new LogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LogDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: LogDto): Observable<LogDto> {
        let url_ = this.baseUrl + "/api/services/app/Log/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<LogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LogDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<LogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogDto.fromJS(resultData200) : new LogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LogDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Log/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LogActionTypeServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<LogActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LogActionType/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<LogActionTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LogActionTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<LogActionTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogActionTypeDto.fromJS(resultData200) : new LogActionTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LogActionTypeDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfLogActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LogActionType/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLogActionTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLogActionTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfLogActionTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLogActionTypeDto.fromJS(resultData200) : new PagedResultDtoOfLogActionTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfLogActionTypeDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: LogActionTypeDto): Observable<LogActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LogActionType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<LogActionTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LogActionTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<LogActionTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogActionTypeDto.fromJS(resultData200) : new LogActionTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LogActionTypeDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: LogActionTypeDto): Observable<LogActionTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/LogActionType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<LogActionTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LogActionTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<LogActionTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogActionTypeDto.fromJS(resultData200) : new LogActionTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LogActionTypeDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LogActionType/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class OnlineRegistrationResponseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<OnlineRegistrationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineRegistrationResponse/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<OnlineRegistrationResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OnlineRegistrationResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<OnlineRegistrationResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OnlineRegistrationResponseDto.fromJS(resultData200) : new OnlineRegistrationResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OnlineRegistrationResponseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfOnlineRegistrationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineRegistrationResponse/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOnlineRegistrationResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfOnlineRegistrationResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfOnlineRegistrationResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOnlineRegistrationResponseDto.fromJS(resultData200) : new PagedResultDtoOfOnlineRegistrationResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfOnlineRegistrationResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: OnlineRegistrationResponseDto): Observable<OnlineRegistrationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineRegistrationResponse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<OnlineRegistrationResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OnlineRegistrationResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<OnlineRegistrationResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OnlineRegistrationResponseDto.fromJS(resultData200) : new OnlineRegistrationResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OnlineRegistrationResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: OnlineRegistrationResponseDto): Observable<OnlineRegistrationResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineRegistrationResponse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<OnlineRegistrationResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OnlineRegistrationResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<OnlineRegistrationResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OnlineRegistrationResponseDto.fromJS(resultData200) : new OnlineRegistrationResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OnlineRegistrationResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineRegistrationResponse/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class PhaseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<PhaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Phase/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<PhaseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<PhaseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseDto.fromJS(resultData200) : new PhaseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfPhaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Phase/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPhaseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfPhaseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfPhaseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPhaseDto.fromJS(resultData200) : new PagedResultDtoOfPhaseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfPhaseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: PhaseDto): Observable<PhaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Phase/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<PhaseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<PhaseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseDto.fromJS(resultData200) : new PhaseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: PhaseDto): Observable<PhaseDto> {
        let url_ = this.baseUrl + "/api/services/app/Phase/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<PhaseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<PhaseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseDto.fromJS(resultData200) : new PhaseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Phase/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class PhaseQuestionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<PhaseQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseQuestion/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<PhaseQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<PhaseQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseQuestionDto.fromJS(resultData200) : new PhaseQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseQuestionDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfPhaseQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseQuestion/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPhaseQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfPhaseQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfPhaseQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPhaseQuestionDto.fromJS(resultData200) : new PagedResultDtoOfPhaseQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfPhaseQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: PhaseQuestionDto): Observable<PhaseQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseQuestion/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<PhaseQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<PhaseQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseQuestionDto.fromJS(resultData200) : new PhaseQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: PhaseQuestionDto): Observable<PhaseQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseQuestion/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<PhaseQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<PhaseQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseQuestionDto.fromJS(resultData200) : new PhaseQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseQuestionDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PhaseQuestion/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class PhaseSurveyServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<PhaseSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseSurvey/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<PhaseSurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseSurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<PhaseSurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseSurveyDto.fromJS(resultData200) : new PhaseSurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseSurveyDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfPhaseSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseSurvey/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPhaseSurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfPhaseSurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfPhaseSurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPhaseSurveyDto.fromJS(resultData200) : new PagedResultDtoOfPhaseSurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfPhaseSurveyDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: PhaseSurveyDto): Observable<PhaseSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseSurvey/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<PhaseSurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseSurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<PhaseSurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseSurveyDto.fromJS(resultData200) : new PhaseSurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseSurveyDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: PhaseSurveyDto): Observable<PhaseSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/PhaseSurvey/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<PhaseSurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PhaseSurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<PhaseSurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhaseSurveyDto.fromJS(resultData200) : new PhaseSurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PhaseSurveyDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PhaseSurvey/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QualityCallBackResponseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<QualityCallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponse/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QualityCallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QualityCallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QualityCallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QualityCallBackResponseDto.fromJS(resultData200) : new QualityCallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QualityCallBackResponseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQualityCallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponse/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQualityCallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQualityCallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQualityCallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQualityCallBackResponseDto.fromJS(resultData200) : new PagedResultDtoOfQualityCallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQualityCallBackResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QualityCallBackResponseDto): Observable<QualityCallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QualityCallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QualityCallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QualityCallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QualityCallBackResponseDto.fromJS(resultData200) : new QualityCallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QualityCallBackResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QualityCallBackResponseDto): Observable<QualityCallBackResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QualityCallBackResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QualityCallBackResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QualityCallBackResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QualityCallBackResponseDto.fromJS(resultData200) : new QualityCallBackResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QualityCallBackResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponse/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QualityCallBackResponseAnswerServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<QualityCallBackResponseAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponseAnswer/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QualityCallBackResponseAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QualityCallBackResponseAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QualityCallBackResponseAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QualityCallBackResponseAnswerDto.fromJS(resultData200) : new QualityCallBackResponseAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QualityCallBackResponseAnswerDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQualityCallBackResponseAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponseAnswer/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQualityCallBackResponseAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQualityCallBackResponseAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQualityCallBackResponseAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQualityCallBackResponseAnswerDto.fromJS(resultData200) : new PagedResultDtoOfQualityCallBackResponseAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQualityCallBackResponseAnswerDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QualityCallBackResponseAnswerDto): Observable<QualityCallBackResponseAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponseAnswer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QualityCallBackResponseAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QualityCallBackResponseAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QualityCallBackResponseAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QualityCallBackResponseAnswerDto.fromJS(resultData200) : new QualityCallBackResponseAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QualityCallBackResponseAnswerDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QualityCallBackResponseAnswerDto): Observable<QualityCallBackResponseAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponseAnswer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QualityCallBackResponseAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QualityCallBackResponseAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QualityCallBackResponseAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QualityCallBackResponseAnswerDto.fromJS(resultData200) : new QualityCallBackResponseAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QualityCallBackResponseAnswerDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QualityCallBackResponseAnswer/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionDto.fromJS(resultData200) : new QuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionDto.fromJS(resultData200) : new PagedResultDtoOfQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionDto): Observable<QuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionDto.fromJS(resultData200) : new QuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionDto): Observable<QuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/Question/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionDto.fromJS(resultData200) : new QuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Question/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionAttachmentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionAttachment/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionAttachmentDto.fromJS(resultData200) : new QuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionAttachmentDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionAttachment/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionAttachmentDto.fromJS(resultData200) : new PagedResultDtoOfQuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionAttachmentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionAttachmentDto): Observable<QuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionAttachment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionAttachmentDto.fromJS(resultData200) : new QuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionAttachmentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionAttachmentDto): Observable<QuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionAttachment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionAttachmentDto.fromJS(resultData200) : new QuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionAttachmentDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionAttachment/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionGroupServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionGroup/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionGroupDto.fromJS(resultData200) : new QuestionGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionGroupDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionGroup/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionGroupDto.fromJS(resultData200) : new PagedResultDtoOfQuestionGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionGroupDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionGroupDto): Observable<QuestionGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionGroup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionGroupDto.fromJS(resultData200) : new QuestionGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionGroupDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionGroupDto): Observable<QuestionGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionGroup/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionGroupDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionGroupDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionGroupDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionGroupDto.fromJS(resultData200) : new QuestionGroupDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionGroupDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionGroup/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionnaireServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/app/Questionnaire/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionnaireDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/app/Questionnaire/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionnaireDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionnaireDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionnaireDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionnaireDto.fromJS(resultData200) : new PagedResultDtoOfQuestionnaireDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionnaireDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionnaireDto): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/app/Questionnaire/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionnaireDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionnaireDto): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/app/Questionnaire/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionnaireDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Questionnaire/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionnaireExamResultServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionnaireExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireExamResult/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionnaireExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionnaireExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireExamResultDto.fromJS(resultData200) : new QuestionnaireExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireExamResultDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionnaireExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireExamResult/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionnaireExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionnaireExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionnaireExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionnaireExamResultDto.fromJS(resultData200) : new PagedResultDtoOfQuestionnaireExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionnaireExamResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionnaireExamResultDto): Observable<QuestionnaireExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireExamResult/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionnaireExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireExamResultDto.fromJS(resultData200) : new QuestionnaireExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireExamResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionnaireExamResultDto): Observable<QuestionnaireExamResultDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireExamResult/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireExamResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireExamResultDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionnaireExamResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireExamResultDto.fromJS(resultData200) : new QuestionnaireExamResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireExamResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireExamResult/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionnaireQuestionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionnaireQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestion/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionnaireQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionDto.fromJS(resultData200) : new QuestionnaireQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionnaireQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestion/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionnaireQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionnaireQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionnaireQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionnaireQuestionDto.fromJS(resultData200) : new PagedResultDtoOfQuestionnaireQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionnaireQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionnaireQuestionDto): Observable<QuestionnaireQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestion/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionnaireQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionDto.fromJS(resultData200) : new QuestionnaireQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionnaireQuestionDto): Observable<QuestionnaireQuestionDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestion/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionnaireQuestionDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionDto.fromJS(resultData200) : new QuestionnaireQuestionDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestion/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionnaireQuestionAnswerServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionnaireQuestionAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAnswer/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionnaireQuestionAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionAnswerDto.fromJS(resultData200) : new QuestionnaireQuestionAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionAnswerDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionnaireQuestionAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAnswer/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionnaireQuestionAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionnaireQuestionAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionnaireQuestionAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionnaireQuestionAnswerDto.fromJS(resultData200) : new PagedResultDtoOfQuestionnaireQuestionAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionnaireQuestionAnswerDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionnaireQuestionAnswerDto): Observable<QuestionnaireQuestionAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAnswer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionnaireQuestionAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionAnswerDto.fromJS(resultData200) : new QuestionnaireQuestionAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionAnswerDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionnaireQuestionAnswerDto): Observable<QuestionnaireQuestionAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAnswer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionnaireQuestionAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionAnswerDto.fromJS(resultData200) : new QuestionnaireQuestionAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionAnswerDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAnswer/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionnaireQuestionAttachmentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionnaireQuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAttachment/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionnaireQuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionAttachmentDto.fromJS(resultData200) : new QuestionnaireQuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionAttachmentDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionnaireQuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAttachment/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionnaireQuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionnaireQuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionnaireQuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionnaireQuestionAttachmentDto.fromJS(resultData200) : new PagedResultDtoOfQuestionnaireQuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionnaireQuestionAttachmentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionnaireQuestionAttachmentDto): Observable<QuestionnaireQuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAttachment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionnaireQuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionAttachmentDto.fromJS(resultData200) : new QuestionnaireQuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionAttachmentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionnaireQuestionAttachmentDto): Observable<QuestionnaireQuestionAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAttachment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionnaireQuestionAttachmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionnaireQuestionAttachmentDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionnaireQuestionAttachmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireQuestionAttachmentDto.fromJS(resultData200) : new QuestionnaireQuestionAttachmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionnaireQuestionAttachmentDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionnaireQuestionAttachment/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionTemplateServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplate/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateDto.fromJS(resultData200) : new QuestionTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplate/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionTemplateDto.fromJS(resultData200) : new PagedResultDtoOfQuestionTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionTemplateDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionTemplateDto): Observable<QuestionTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplate/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateDto.fromJS(resultData200) : new QuestionTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionTemplateDto): Observable<QuestionTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateDto.fromJS(resultData200) : new QuestionTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplate/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionTemplateAnswerServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionTemplateAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateAnswer/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionTemplateAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateAnswerDto.fromJS(resultData200) : new QuestionTemplateAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateAnswerDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionTemplateAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateAnswer/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionTemplateAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionTemplateAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionTemplateAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionTemplateAnswerDto.fromJS(resultData200) : new PagedResultDtoOfQuestionTemplateAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionTemplateAnswerDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionTemplateAnswerDto): Observable<QuestionTemplateAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateAnswer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionTemplateAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateAnswerDto.fromJS(resultData200) : new QuestionTemplateAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateAnswerDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionTemplateAnswerDto): Observable<QuestionTemplateAnswerDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateAnswer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateAnswerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateAnswerDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionTemplateAnswerDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateAnswerDto.fromJS(resultData200) : new QuestionTemplateAnswerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateAnswerDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateAnswer/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionTemplateCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionTemplateCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateCategory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionTemplateCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateCategoryDto.fromJS(resultData200) : new QuestionTemplateCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateCategoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionTemplateCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateCategory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionTemplateCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionTemplateCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionTemplateCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionTemplateCategoryDto.fromJS(resultData200) : new PagedResultDtoOfQuestionTemplateCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionTemplateCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionTemplateCategoryDto): Observable<QuestionTemplateCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionTemplateCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateCategoryDto.fromJS(resultData200) : new QuestionTemplateCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionTemplateCategoryDto): Observable<QuestionTemplateCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionTemplateCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateCategoryDto.fromJS(resultData200) : new QuestionTemplateCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateCategory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionTemplateSubCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionTemplateSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateSubCategory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionTemplateSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateSubCategoryDto.fromJS(resultData200) : new QuestionTemplateSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateSubCategoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionTemplateSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateSubCategory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionTemplateSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionTemplateSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionTemplateSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionTemplateSubCategoryDto.fromJS(resultData200) : new PagedResultDtoOfQuestionTemplateSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionTemplateSubCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionTemplateSubCategoryDto): Observable<QuestionTemplateSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateSubCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionTemplateSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateSubCategoryDto.fromJS(resultData200) : new QuestionTemplateSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateSubCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionTemplateSubCategoryDto): Observable<QuestionTemplateSubCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateSubCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateSubCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateSubCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionTemplateSubCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateSubCategoryDto.fromJS(resultData200) : new QuestionTemplateSubCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateSubCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateSubCategory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class QuestionTemplateValidationRuleServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<QuestionTemplateValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateValidationRule/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<QuestionTemplateValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateValidationRuleDto.fromJS(resultData200) : new QuestionTemplateValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateValidationRuleDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfQuestionTemplateValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateValidationRule/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuestionTemplateValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuestionTemplateValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfQuestionTemplateValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfQuestionTemplateValidationRuleDto.fromJS(resultData200) : new PagedResultDtoOfQuestionTemplateValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfQuestionTemplateValidationRuleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: QuestionTemplateValidationRuleDto): Observable<QuestionTemplateValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateValidationRule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<QuestionTemplateValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateValidationRuleDto.fromJS(resultData200) : new QuestionTemplateValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateValidationRuleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: QuestionTemplateValidationRuleDto): Observable<QuestionTemplateValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateValidationRule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<QuestionTemplateValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<QuestionTemplateValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<QuestionTemplateValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionTemplateValidationRuleDto.fromJS(resultData200) : new QuestionTemplateValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<QuestionTemplateValidationRuleDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuestionTemplateValidationRule/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RandomizedRegularDataByDomainServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<RandomizedRegularDataByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDataByDomain/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<RandomizedRegularDataByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RandomizedRegularDataByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<RandomizedRegularDataByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RandomizedRegularDataByDomainDto.fromJS(resultData200) : new RandomizedRegularDataByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RandomizedRegularDataByDomainDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfRandomizedRegularDataByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDataByDomain/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRandomizedRegularDataByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfRandomizedRegularDataByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfRandomizedRegularDataByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRandomizedRegularDataByDomainDto.fromJS(resultData200) : new PagedResultDtoOfRandomizedRegularDataByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfRandomizedRegularDataByDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: RandomizedRegularDataByDomainDto): Observable<RandomizedRegularDataByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDataByDomain/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<RandomizedRegularDataByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RandomizedRegularDataByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<RandomizedRegularDataByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RandomizedRegularDataByDomainDto.fromJS(resultData200) : new RandomizedRegularDataByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RandomizedRegularDataByDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: RandomizedRegularDataByDomainDto): Observable<RandomizedRegularDataByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDataByDomain/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<RandomizedRegularDataByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RandomizedRegularDataByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<RandomizedRegularDataByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RandomizedRegularDataByDomainDto.fromJS(resultData200) : new RandomizedRegularDataByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RandomizedRegularDataByDomainDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDataByDomain/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RandomizedRegularDatumServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<RandomizedRegularDatumDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDatum/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<RandomizedRegularDatumDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RandomizedRegularDatumDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<RandomizedRegularDatumDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RandomizedRegularDatumDto.fromJS(resultData200) : new RandomizedRegularDatumDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RandomizedRegularDatumDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfRandomizedRegularDatumDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDatum/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRandomizedRegularDatumDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfRandomizedRegularDatumDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfRandomizedRegularDatumDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRandomizedRegularDatumDto.fromJS(resultData200) : new PagedResultDtoOfRandomizedRegularDatumDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfRandomizedRegularDatumDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: RandomizedRegularDatumDto): Observable<RandomizedRegularDatumDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDatum/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<RandomizedRegularDatumDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RandomizedRegularDatumDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<RandomizedRegularDatumDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RandomizedRegularDatumDto.fromJS(resultData200) : new RandomizedRegularDatumDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RandomizedRegularDatumDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: RandomizedRegularDatumDto): Observable<RandomizedRegularDatumDto> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDatum/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<RandomizedRegularDatumDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RandomizedRegularDatumDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<RandomizedRegularDatumDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RandomizedRegularDatumDto.fromJS(resultData200) : new RandomizedRegularDatumDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RandomizedRegularDatumDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RandomizedRegularDatum/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RegExServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<RegExDto> {
        let url_ = this.baseUrl + "/api/services/app/RegEx/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<RegExDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegExDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<RegExDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegExDto.fromJS(resultData200) : new RegExDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegExDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfRegExDto> {
        let url_ = this.baseUrl + "/api/services/app/RegEx/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRegExDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfRegExDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfRegExDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRegExDto.fromJS(resultData200) : new PagedResultDtoOfRegExDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfRegExDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: RegExDto): Observable<RegExDto> {
        let url_ = this.baseUrl + "/api/services/app/RegEx/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<RegExDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegExDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<RegExDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegExDto.fromJS(resultData200) : new RegExDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegExDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: RegExDto): Observable<RegExDto> {
        let url_ = this.baseUrl + "/api/services/app/RegEx/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<RegExDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegExDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<RegExDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegExDto.fromJS(resultData200) : new RegExDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegExDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RegEx/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RegExCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<RegExCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/RegExCategory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<RegExCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegExCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<RegExCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegExCategoryDto.fromJS(resultData200) : new RegExCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegExCategoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfRegExCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/RegExCategory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRegExCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfRegExCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfRegExCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRegExCategoryDto.fromJS(resultData200) : new PagedResultDtoOfRegExCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfRegExCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: RegExCategoryDto): Observable<RegExCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/RegExCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<RegExCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegExCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<RegExCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegExCategoryDto.fromJS(resultData200) : new RegExCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegExCategoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: RegExCategoryDto): Observable<RegExCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/RegExCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<RegExCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegExCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<RegExCategoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegExCategoryDto.fromJS(resultData200) : new RegExCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegExCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RegExCategory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ReportTypeServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ReportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportType/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ReportTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ReportTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ReportTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReportTypeDto.fromJS(resultData200) : new ReportTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ReportTypeDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfReportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportType/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfReportTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfReportTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfReportTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfReportTypeDto.fromJS(resultData200) : new PagedResultDtoOfReportTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfReportTypeDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ReportTypeDto): Observable<ReportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ReportTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ReportTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ReportTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReportTypeDto.fromJS(resultData200) : new ReportTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ReportTypeDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ReportTypeDto): Observable<ReportTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ReportTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ReportTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ReportTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReportTypeDto.fromJS(resultData200) : new ReportTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ReportTypeDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportType/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ResponseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Response/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseDto.fromJS(resultData200) : new ResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResponseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Response/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfResponseDto.fromJS(resultData200) : new PagedResultDtoOfResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ResponseDto): Observable<ResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Response/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseDto.fromJS(resultData200) : new ResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ResponseDto): Observable<ResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Response/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseDto.fromJS(resultData200) : new ResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Response/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ResponseSubStatusServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ResponseSubStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/ResponseSubStatus/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ResponseSubStatusDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResponseSubStatusDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ResponseSubStatusDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseSubStatusDto.fromJS(resultData200) : new ResponseSubStatusDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResponseSubStatusDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfResponseSubStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/ResponseSubStatus/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfResponseSubStatusDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfResponseSubStatusDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfResponseSubStatusDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfResponseSubStatusDto.fromJS(resultData200) : new PagedResultDtoOfResponseSubStatusDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfResponseSubStatusDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ResponseSubStatusDto): Observable<ResponseSubStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/ResponseSubStatus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ResponseSubStatusDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResponseSubStatusDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ResponseSubStatusDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseSubStatusDto.fromJS(resultData200) : new ResponseSubStatusDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResponseSubStatusDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ResponseSubStatusDto): Observable<ResponseSubStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/ResponseSubStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ResponseSubStatusDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResponseSubStatusDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ResponseSubStatusDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseSubStatusDto.fromJS(resultData200) : new ResponseSubStatusDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResponseSubStatusDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ResponseSubStatus/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SampleServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<SampleDto> {
        let url_ = this.baseUrl + "/api/services/app/Sample/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SampleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SampleDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SampleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SampleDto.fromJS(resultData200) : new SampleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SampleDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfSampleDto> {
        let url_ = this.baseUrl + "/api/services/app/Sample/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSampleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSampleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfSampleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSampleDto.fromJS(resultData200) : new PagedResultDtoOfSampleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSampleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: SampleDto): Observable<SampleDto> {
        let url_ = this.baseUrl + "/api/services/app/Sample/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<SampleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SampleDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<SampleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SampleDto.fromJS(resultData200) : new SampleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SampleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: SampleDto): Observable<SampleDto> {
        let url_ = this.baseUrl + "/api/services/app/Sample/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<SampleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SampleDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<SampleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SampleDto.fromJS(resultData200) : new SampleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SampleDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sample/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrentLoginInformations(response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentLoginInformations(response: Response): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SimilarityDataByCallCenterServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<SimilarityDataByCallCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByCallCenter/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SimilarityDataByCallCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityDataByCallCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SimilarityDataByCallCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityDataByCallCenterDto.fromJS(resultData200) : new SimilarityDataByCallCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityDataByCallCenterDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfSimilarityDataByCallCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByCallCenter/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSimilarityDataByCallCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSimilarityDataByCallCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfSimilarityDataByCallCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSimilarityDataByCallCenterDto.fromJS(resultData200) : new PagedResultDtoOfSimilarityDataByCallCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSimilarityDataByCallCenterDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: SimilarityDataByCallCenterDto): Observable<SimilarityDataByCallCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByCallCenter/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<SimilarityDataByCallCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityDataByCallCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<SimilarityDataByCallCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityDataByCallCenterDto.fromJS(resultData200) : new SimilarityDataByCallCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityDataByCallCenterDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: SimilarityDataByCallCenterDto): Observable<SimilarityDataByCallCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByCallCenter/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<SimilarityDataByCallCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityDataByCallCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<SimilarityDataByCallCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityDataByCallCenterDto.fromJS(resultData200) : new SimilarityDataByCallCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityDataByCallCenterDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByCallCenter/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SimilarityDataByQualityServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<SimilarityDataByQualityDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByQuality/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SimilarityDataByQualityDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityDataByQualityDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SimilarityDataByQualityDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityDataByQualityDto.fromJS(resultData200) : new SimilarityDataByQualityDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityDataByQualityDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfSimilarityDataByQualityDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByQuality/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSimilarityDataByQualityDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSimilarityDataByQualityDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfSimilarityDataByQualityDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSimilarityDataByQualityDto.fromJS(resultData200) : new PagedResultDtoOfSimilarityDataByQualityDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSimilarityDataByQualityDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: SimilarityDataByQualityDto): Observable<SimilarityDataByQualityDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByQuality/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<SimilarityDataByQualityDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityDataByQualityDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<SimilarityDataByQualityDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityDataByQualityDto.fromJS(resultData200) : new SimilarityDataByQualityDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityDataByQualityDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: SimilarityDataByQualityDto): Observable<SimilarityDataByQualityDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByQuality/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<SimilarityDataByQualityDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityDataByQualityDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<SimilarityDataByQualityDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityDataByQualityDto.fromJS(resultData200) : new SimilarityDataByQualityDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityDataByQualityDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityDataByQuality/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SimilarityPercentageServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<SimilarityPercentageDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityPercentage/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SimilarityPercentageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityPercentageDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SimilarityPercentageDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityPercentageDto.fromJS(resultData200) : new SimilarityPercentageDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityPercentageDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfSimilarityPercentageDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityPercentage/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSimilarityPercentageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSimilarityPercentageDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfSimilarityPercentageDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSimilarityPercentageDto.fromJS(resultData200) : new PagedResultDtoOfSimilarityPercentageDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSimilarityPercentageDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: SimilarityPercentageDto): Observable<SimilarityPercentageDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityPercentage/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<SimilarityPercentageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityPercentageDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<SimilarityPercentageDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityPercentageDto.fromJS(resultData200) : new SimilarityPercentageDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityPercentageDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: SimilarityPercentageDto): Observable<SimilarityPercentageDto> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityPercentage/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<SimilarityPercentageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SimilarityPercentageDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<SimilarityPercentageDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SimilarityPercentageDto.fromJS(resultData200) : new SimilarityPercentageDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SimilarityPercentageDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SimilarityPercentage/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SurveyServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<SurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/Survey/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SurveyDto.fromJS(resultData200) : new SurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SurveyDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfSurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/Survey/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfSurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSurveyDto.fromJS(resultData200) : new PagedResultDtoOfSurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSurveyDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: SurveyDto): Observable<SurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/Survey/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<SurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<SurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SurveyDto.fromJS(resultData200) : new SurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SurveyDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: SurveyDto): Observable<SurveyDto> {
        let url_ = this.baseUrl + "/api/services/app/Survey/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<SurveyDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SurveyDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<SurveyDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SurveyDto.fromJS(resultData200) : new SurveyDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SurveyDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Survey/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SyncLogServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<SyncLogDto> {
        let url_ = this.baseUrl + "/api/services/app/SyncLog/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<SyncLogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SyncLogDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<SyncLogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncLogDto.fromJS(resultData200) : new SyncLogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SyncLogDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfSyncLogDto> {
        let url_ = this.baseUrl + "/api/services/app/SyncLog/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSyncLogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSyncLogDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfSyncLogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSyncLogDto.fromJS(resultData200) : new PagedResultDtoOfSyncLogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSyncLogDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: SyncLogDto): Observable<SyncLogDto> {
        let url_ = this.baseUrl + "/api/services/app/SyncLog/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<SyncLogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SyncLogDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<SyncLogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncLogDto.fromJS(resultData200) : new SyncLogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SyncLogDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: SyncLogDto): Observable<SyncLogDto> {
        let url_ = this.baseUrl + "/api/services/app/SyncLog/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<SyncLogDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SyncLogDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<SyncLogDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncLogDto.fromJS(resultData200) : new SyncLogDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SyncLogDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SyncLog/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TempFilteredResponseServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TempFilteredResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/TempFilteredResponse/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TempFilteredResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TempFilteredResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TempFilteredResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TempFilteredResponseDto.fromJS(resultData200) : new TempFilteredResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TempFilteredResponseDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTempFilteredResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/TempFilteredResponse/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTempFilteredResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTempFilteredResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTempFilteredResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTempFilteredResponseDto.fromJS(resultData200) : new PagedResultDtoOfTempFilteredResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTempFilteredResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TempFilteredResponseDto): Observable<TempFilteredResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/TempFilteredResponse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TempFilteredResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TempFilteredResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TempFilteredResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TempFilteredResponseDto.fromJS(resultData200) : new TempFilteredResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TempFilteredResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TempFilteredResponseDto): Observable<TempFilteredResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/TempFilteredResponse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TempFilteredResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TempFilteredResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TempFilteredResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TempFilteredResponseDto.fromJS(resultData200) : new TempFilteredResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TempFilteredResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TempFilteredResponse/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingAttendanceServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingAttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingAttendance/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingAttendanceDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingAttendanceDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingAttendanceDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingAttendanceDto.fromJS(resultData200) : new TrainingAttendanceDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingAttendanceDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingAttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingAttendance/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingAttendanceDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingAttendanceDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingAttendanceDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingAttendanceDto.fromJS(resultData200) : new PagedResultDtoOfTrainingAttendanceDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingAttendanceDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingAttendanceDto): Observable<TrainingAttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingAttendance/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingAttendanceDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingAttendanceDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingAttendanceDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingAttendanceDto.fromJS(resultData200) : new TrainingAttendanceDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingAttendanceDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingAttendanceDto): Observable<TrainingAttendanceDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingAttendance/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingAttendanceDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingAttendanceDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingAttendanceDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingAttendanceDto.fromJS(resultData200) : new TrainingAttendanceDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingAttendanceDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingAttendance/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingCenterServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenter/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingCenterDto.fromJS(resultData200) : new TrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingCenterDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenter/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingCenterDto.fromJS(resultData200) : new PagedResultDtoOfTrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingCenterDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingCenterDto): Observable<TrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenter/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingCenterDto.fromJS(resultData200) : new TrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingCenterDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingCenterDto): Observable<TrainingCenterDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenter/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingCenterDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingCenterDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingCenterDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingCenterDto.fromJS(resultData200) : new TrainingCenterDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingCenterDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenter/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingCenterUserServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingCenterUserDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenterUser/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingCenterUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingCenterUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingCenterUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingCenterUserDto.fromJS(resultData200) : new TrainingCenterUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingCenterUserDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingCenterUserDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenterUser/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingCenterUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingCenterUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingCenterUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingCenterUserDto.fromJS(resultData200) : new PagedResultDtoOfTrainingCenterUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingCenterUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingCenterUserDto): Observable<TrainingCenterUserDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenterUser/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingCenterUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingCenterUserDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingCenterUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingCenterUserDto.fromJS(resultData200) : new TrainingCenterUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingCenterUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingCenterUserDto): Observable<TrainingCenterUserDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenterUser/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingCenterUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingCenterUserDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingCenterUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingCenterUserDto.fromJS(resultData200) : new TrainingCenterUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingCenterUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingCenterUser/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingExamServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingExamDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingExam/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingExamDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingExamDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingExamDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingExamDto.fromJS(resultData200) : new TrainingExamDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingExamDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingExamDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingExam/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingExamDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingExamDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingExamDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingExamDto.fromJS(resultData200) : new PagedResultDtoOfTrainingExamDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingExamDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingExamDto): Observable<TrainingExamDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingExam/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingExamDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingExamDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingExamDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingExamDto.fromJS(resultData200) : new TrainingExamDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingExamDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingExamDto): Observable<TrainingExamDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingExam/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingExamDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingExamDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingExamDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingExamDto.fromJS(resultData200) : new TrainingExamDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingExamDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingExam/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingMemberServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingMember/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingMemberDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingMemberDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingMemberDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingMemberDto.fromJS(resultData200) : new TrainingMemberDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingMemberDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingMember/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingMemberDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingMemberDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingMemberDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingMemberDto.fromJS(resultData200) : new PagedResultDtoOfTrainingMemberDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingMemberDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingMemberDto): Observable<TrainingMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingMember/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingMemberDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingMemberDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingMemberDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingMemberDto.fromJS(resultData200) : new TrainingMemberDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingMemberDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingMemberDto): Observable<TrainingMemberDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingMember/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingMemberDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingMemberDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingMemberDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingMemberDto.fromJS(resultData200) : new TrainingMemberDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingMemberDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingMember/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingProgramServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgram/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingProgramDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingProgramDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingProgramDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingProgramDto.fromJS(resultData200) : new TrainingProgramDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingProgramDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgram/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingProgramDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingProgramDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingProgramDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingProgramDto.fromJS(resultData200) : new PagedResultDtoOfTrainingProgramDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingProgramDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingProgramDto): Observable<TrainingProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgram/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingProgramDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingProgramDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingProgramDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingProgramDto.fromJS(resultData200) : new TrainingProgramDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingProgramDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingProgramDto): Observable<TrainingProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgram/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingProgramDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingProgramDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingProgramDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingProgramDto.fromJS(resultData200) : new TrainingProgramDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingProgramDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgram/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingProgramDocumentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingProgramDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgramDocument/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingProgramDocumentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingProgramDocumentDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingProgramDocumentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingProgramDocumentDto.fromJS(resultData200) : new TrainingProgramDocumentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingProgramDocumentDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingProgramDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgramDocument/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingProgramDocumentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingProgramDocumentDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingProgramDocumentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingProgramDocumentDto.fromJS(resultData200) : new PagedResultDtoOfTrainingProgramDocumentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingProgramDocumentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingProgramDocumentDto): Observable<TrainingProgramDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgramDocument/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingProgramDocumentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingProgramDocumentDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingProgramDocumentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingProgramDocumentDto.fromJS(resultData200) : new TrainingProgramDocumentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingProgramDocumentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingProgramDocumentDto): Observable<TrainingProgramDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgramDocument/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingProgramDocumentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingProgramDocumentDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingProgramDocumentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingProgramDocumentDto.fromJS(resultData200) : new TrainingProgramDocumentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingProgramDocumentDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingProgramDocument/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TrainingResultServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<TrainingResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingResult/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<TrainingResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingResultDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TrainingResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingResultDto.fromJS(resultData200) : new TrainingResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingResultDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfTrainingResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingResult/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTrainingResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTrainingResultDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTrainingResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTrainingResultDto.fromJS(resultData200) : new PagedResultDtoOfTrainingResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTrainingResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: TrainingResultDto): Observable<TrainingResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingResult/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<TrainingResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingResultDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TrainingResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingResultDto.fromJS(resultData200) : new TrainingResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: TrainingResultDto): Observable<TrainingResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TrainingResult/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<TrainingResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TrainingResultDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TrainingResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TrainingResultDto.fromJS(resultData200) : new TrainingResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TrainingResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TrainingResult/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @fileName (optional) 
     * @return Success
     */
    getImage(fileName?: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Upload/GetImage?";
        if (fileName !== undefined)
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetImage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetImage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGetImage(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @file (optional) 
     * @return Success
     */
    uploadFile(file?: any): Observable<string> {
        let url_ = this.baseUrl + "/api/Upload/UploadFile?";
        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUploadFile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUploadFile(response_);
                } catch (e) {
                    return <Observable<string>><any>Observable.throw(e);
                }
            } else
                return <Observable<string>><any>Observable.throw(response_);
        });
    }

    protected processUploadFile(response: Response): Observable<string> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<string>(<any>null);
    }
}

@Injectable()
export class UploadedReportServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UploadedReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReport/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UploadedReportDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UploadedReportDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UploadedReportDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadedReportDto.fromJS(resultData200) : new UploadedReportDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UploadedReportDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUploadedReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReport/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUploadedReportDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUploadedReportDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUploadedReportDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUploadedReportDto.fromJS(resultData200) : new PagedResultDtoOfUploadedReportDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUploadedReportDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UploadedReportDto): Observable<UploadedReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReport/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UploadedReportDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UploadedReportDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UploadedReportDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadedReportDto.fromJS(resultData200) : new UploadedReportDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UploadedReportDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UploadedReportDto): Observable<UploadedReportDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReport/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UploadedReportDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UploadedReportDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UploadedReportDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadedReportDto.fromJS(resultData200) : new UploadedReportDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UploadedReportDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReport/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UploadedReportRoleServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id?: string): Observable<UploadedReportRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReportRole/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UploadedReportRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UploadedReportRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UploadedReportRoleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadedReportRoleDto.fromJS(resultData200) : new UploadedReportRoleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UploadedReportRoleDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUploadedReportRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReportRole/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUploadedReportRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUploadedReportRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUploadedReportRoleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUploadedReportRoleDto.fromJS(resultData200) : new PagedResultDtoOfUploadedReportRoleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUploadedReportRoleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UploadedReportRoleDto): Observable<UploadedReportRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReportRole/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UploadedReportRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UploadedReportRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UploadedReportRoleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadedReportRoleDto.fromJS(resultData200) : new UploadedReportRoleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UploadedReportRoleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UploadedReportRoleDto): Observable<UploadedReportRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReportRole/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UploadedReportRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UploadedReportRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UploadedReportRoleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadedReportRoleDto.fromJS(resultData200) : new UploadedReportRoleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UploadedReportRoleDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id?: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UploadedReportRole/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserApplicationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id?: string): Observable<UserApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserApplication/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserApplicationDto.fromJS(resultData200) : new UserApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserApplicationDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserApplication/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserApplicationDto.fromJS(resultData200) : new PagedResultDtoOfUserApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserApplicationDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserApplicationDto): Observable<UserApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserApplication/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserApplicationDto.fromJS(resultData200) : new UserApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserApplicationDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserApplicationDto): Observable<UserApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserApplication/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserApplicationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserApplicationDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserApplicationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserApplicationDto.fromJS(resultData200) : new UserApplicationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserApplicationDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id?: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserApplication/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserDomainServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UserDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDomain/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDomainDto.fromJS(resultData200) : new UserDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDomainDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDomain/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDomainDto.fromJS(resultData200) : new PagedResultDtoOfUserDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserDomainDto): Observable<UserDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDomain/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDomainDto.fromJS(resultData200) : new UserDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserDomainDto): Observable<UserDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDomain/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDomainDto.fromJS(resultData200) : new UserDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDomainDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDomain/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserLocationByDomainServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UserLocationByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomain/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserLocationByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLocationByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserLocationByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLocationByDomainDto.fromJS(resultData200) : new UserLocationByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserLocationByDomainDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserLocationByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomain/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserLocationByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserLocationByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserLocationByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserLocationByDomainDto.fromJS(resultData200) : new PagedResultDtoOfUserLocationByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserLocationByDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserLocationByDomainDto): Observable<UserLocationByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomain/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserLocationByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLocationByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserLocationByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLocationByDomainDto.fromJS(resultData200) : new UserLocationByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserLocationByDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserLocationByDomainDto): Observable<UserLocationByDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomain/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserLocationByDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLocationByDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserLocationByDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLocationByDomainDto.fromJS(resultData200) : new UserLocationByDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserLocationByDomainDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomain/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserLocationByDomainsHistoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UserLocationByDomainsHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomainsHistory/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserLocationByDomainsHistoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLocationByDomainsHistoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserLocationByDomainsHistoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLocationByDomainsHistoryDto.fromJS(resultData200) : new UserLocationByDomainsHistoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserLocationByDomainsHistoryDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserLocationByDomainsHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomainsHistory/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserLocationByDomainsHistoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserLocationByDomainsHistoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserLocationByDomainsHistoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserLocationByDomainsHistoryDto.fromJS(resultData200) : new PagedResultDtoOfUserLocationByDomainsHistoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserLocationByDomainsHistoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserLocationByDomainsHistoryDto): Observable<UserLocationByDomainsHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomainsHistory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserLocationByDomainsHistoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLocationByDomainsHistoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserLocationByDomainsHistoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLocationByDomainsHistoryDto.fromJS(resultData200) : new UserLocationByDomainsHistoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserLocationByDomainsHistoryDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserLocationByDomainsHistoryDto): Observable<UserLocationByDomainsHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomainsHistory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserLocationByDomainsHistoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLocationByDomainsHistoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserLocationByDomainsHistoryDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLocationByDomainsHistoryDto.fromJS(resultData200) : new UserLocationByDomainsHistoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserLocationByDomainsHistoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLocationByDomainsHistory/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserProfileServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserProfileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfileDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserProfileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfileDto.fromJS(resultData200) : new UserProfileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfileDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserProfileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserProfileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserProfileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserProfileDto.fromJS(resultData200) : new PagedResultDtoOfUserProfileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserProfileDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserProfileDto): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserProfileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfileDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserProfileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfileDto.fromJS(resultData200) : new UserProfileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfileDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserProfileDto): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserProfileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfileDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserProfileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfileDto.fromJS(resultData200) : new UserProfileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfileDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserProfilesProgressServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UserProfilesProgressDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfilesProgress/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserProfilesProgressDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfilesProgressDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserProfilesProgressDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfilesProgressDto.fromJS(resultData200) : new UserProfilesProgressDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfilesProgressDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserProfilesProgressDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfilesProgress/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserProfilesProgressDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserProfilesProgressDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserProfilesProgressDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserProfilesProgressDto.fromJS(resultData200) : new PagedResultDtoOfUserProfilesProgressDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserProfilesProgressDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserProfilesProgressDto): Observable<UserProfilesProgressDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfilesProgress/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserProfilesProgressDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfilesProgressDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserProfilesProgressDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfilesProgressDto.fromJS(resultData200) : new UserProfilesProgressDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfilesProgressDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserProfilesProgressDto): Observable<UserProfilesProgressDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfilesProgress/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserProfilesProgressDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserProfilesProgressDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserProfilesProgressDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfilesProgressDto.fromJS(resultData200) : new UserProfilesProgressDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserProfilesProgressDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserProfilesProgress/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UsersActiveDomainServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<UsersActiveDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersActiveDomain/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UsersActiveDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersActiveDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UsersActiveDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersActiveDomainDto.fromJS(resultData200) : new UsersActiveDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UsersActiveDomainDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUsersActiveDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersActiveDomain/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUsersActiveDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUsersActiveDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUsersActiveDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUsersActiveDomainDto.fromJS(resultData200) : new PagedResultDtoOfUsersActiveDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUsersActiveDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UsersActiveDomainDto): Observable<UsersActiveDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersActiveDomain/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UsersActiveDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersActiveDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UsersActiveDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersActiveDomainDto.fromJS(resultData200) : new UsersActiveDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UsersActiveDomainDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UsersActiveDomainDto): Observable<UsersActiveDomainDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersActiveDomain/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UsersActiveDomainDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersActiveDomainDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UsersActiveDomainDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersActiveDomainDto.fromJS(resultData200) : new UsersActiveDomainDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UsersActiveDomainDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UsersActiveDomain/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UsersAssignmentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<UsersAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersAssignment/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UsersAssignmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersAssignmentDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UsersAssignmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersAssignmentDto.fromJS(resultData200) : new UsersAssignmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UsersAssignmentDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUsersAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersAssignment/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUsersAssignmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUsersAssignmentDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUsersAssignmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUsersAssignmentDto.fromJS(resultData200) : new PagedResultDtoOfUsersAssignmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUsersAssignmentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UsersAssignmentDto): Observable<UsersAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersAssignment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UsersAssignmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersAssignmentDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UsersAssignmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersAssignmentDto.fromJS(resultData200) : new UsersAssignmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UsersAssignmentDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UsersAssignmentDto): Observable<UsersAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/UsersAssignment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UsersAssignmentDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersAssignmentDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UsersAssignmentDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersAssignmentDto.fromJS(resultData200) : new UsersAssignmentDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UsersAssignmentDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UsersAssignment/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserSurveysTemplateServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id?: string): Observable<UserSurveysTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/UserSurveysTemplate/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<UserSurveysTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserSurveysTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserSurveysTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserSurveysTemplateDto.fromJS(resultData200) : new UserSurveysTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserSurveysTemplateDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfUserSurveysTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/UserSurveysTemplate/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserSurveysTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserSurveysTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserSurveysTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserSurveysTemplateDto.fromJS(resultData200) : new PagedResultDtoOfUserSurveysTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserSurveysTemplateDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: UserSurveysTemplateDto): Observable<UserSurveysTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/UserSurveysTemplate/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<UserSurveysTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserSurveysTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserSurveysTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserSurveysTemplateDto.fromJS(resultData200) : new UserSurveysTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserSurveysTemplateDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: UserSurveysTemplateDto): Observable<UserSurveysTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/UserSurveysTemplate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<UserSurveysTemplateDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserSurveysTemplateDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserSurveysTemplateDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserSurveysTemplateDto.fromJS(resultData200) : new UserSurveysTemplateDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserSurveysTemplateDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id?: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserSurveysTemplate/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ValidationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @dtoName (optional) 
     * @return Success
     */
    getValidations(dtoName?: string): Observable<ValidationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Validation/GetValidations?";
        if (dtoName !== undefined)
            url_ += "DtoName=" + encodeURIComponent("" + dtoName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetValidations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetValidations(response_);
                } catch (e) {
                    return <Observable<ValidationDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ValidationDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetValidations(response: Response): Observable<ValidationDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ValidationDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ValidationDto[]>(<any>null);
    }
}

@Injectable()
export class ViolatedValidationRuleServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<ViolatedValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ViolatedValidationRule/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<ViolatedValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ViolatedValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ViolatedValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ViolatedValidationRuleDto.fromJS(resultData200) : new ViolatedValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ViolatedValidationRuleDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfViolatedValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ViolatedValidationRule/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfViolatedValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfViolatedValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfViolatedValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfViolatedValidationRuleDto.fromJS(resultData200) : new PagedResultDtoOfViolatedValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfViolatedValidationRuleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: ViolatedValidationRuleDto): Observable<ViolatedValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ViolatedValidationRule/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<ViolatedValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ViolatedValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ViolatedValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ViolatedValidationRuleDto.fromJS(resultData200) : new ViolatedValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ViolatedValidationRuleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: ViolatedValidationRuleDto): Observable<ViolatedValidationRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/ViolatedValidationRule/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<ViolatedValidationRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ViolatedValidationRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ViolatedValidationRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ViolatedValidationRuleDto.fromJS(resultData200) : new ViolatedValidationRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ViolatedValidationRuleDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViolatedValidationRule/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class WorkingDataByUserServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: string): Observable<WorkingDataByUserDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingDataByUser/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<WorkingDataByUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<WorkingDataByUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<WorkingDataByUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkingDataByUserDto.fromJS(resultData200) : new WorkingDataByUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WorkingDataByUserDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter?: string, sorting?: string): Observable<PagedResultDtoOfWorkingDataByUserDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingDataByUser/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkingDataByUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkingDataByUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfWorkingDataByUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWorkingDataByUserDto.fromJS(resultData200) : new PagedResultDtoOfWorkingDataByUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfWorkingDataByUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input?: WorkingDataByUserDto): Observable<WorkingDataByUserDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingDataByUser/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<WorkingDataByUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<WorkingDataByUserDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<WorkingDataByUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkingDataByUserDto.fromJS(resultData200) : new WorkingDataByUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WorkingDataByUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input?: WorkingDataByUserDto): Observable<WorkingDataByUserDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkingDataByUser/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<WorkingDataByUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<WorkingDataByUserDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<WorkingDataByUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkingDataByUserDto.fromJS(resultData200) : new WorkingDataByUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WorkingDataByUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkingDataByUser/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

export class AnnouncementDto implements IAnnouncementDto {
    message: string;
    domainId: string;
    domainName: string;
    date: moment.Moment;
    senderId: string;
    id: string;

    constructor(data?: IAnnouncementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.senderId = data["senderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AnnouncementDto {
        let result = new AnnouncementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["senderId"] = this.senderId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AnnouncementDto();
        result.init(json);
        return result;
    }
}

export interface IAnnouncementDto {
    message: string;
    domainId: string;
    domainName: string;
    date: moment.Moment;
    senderId: string;
    id: string;
}

export class PagedResultDtoOfAnnouncementDto implements IPagedResultDtoOfAnnouncementDto {
    totalCount: number;
    items: AnnouncementDto[];

    constructor(data?: IPagedResultDtoOfAnnouncementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AnnouncementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAnnouncementDto {
        let result = new PagedResultDtoOfAnnouncementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAnnouncementDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAnnouncementDto {
    totalCount: number;
    items: AnnouncementDto[];
}

export class ApplicationDto implements IApplicationDto {
    name: string;
    currentPhaseId: string;
    currentPhaseName: string;
    isEnabled: boolean;
    isActive: boolean;
    logo: string;
    categoryId: string;
    categoryName: string;
    availableFor: number;
    id: string;

    constructor(data?: IApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.currentPhaseId = data["currentPhaseId"];
            this.currentPhaseName = data["currentPhaseName"];
            this.isEnabled = data["isEnabled"];
            this.isActive = data["isActive"];
            this.logo = data["logo"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.availableFor = data["availableFor"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationDto {
        let result = new ApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["currentPhaseId"] = this.currentPhaseId;
        data["currentPhaseName"] = this.currentPhaseName;
        data["isEnabled"] = this.isEnabled;
        data["isActive"] = this.isActive;
        data["logo"] = this.logo;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["availableFor"] = this.availableFor;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationDto {
    name: string;
    currentPhaseId: string;
    currentPhaseName: string;
    isEnabled: boolean;
    isActive: boolean;
    logo: string;
    categoryId: string;
    categoryName: string;
    availableFor: number;
    id: string;
}

export class PagedResultDtoOfApplicationDto implements IPagedResultDtoOfApplicationDto {
    totalCount: number;
    items: ApplicationDto[];

    constructor(data?: IPagedResultDtoOfApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApplicationDto {
        let result = new PagedResultDtoOfApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfApplicationDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfApplicationDto {
    totalCount: number;
    items: ApplicationDto[];
}

export class ApplicationCategoryDto implements IApplicationCategoryDto {
    name: string;
    nameEn: string;
    id: string;

    constructor(data?: IApplicationCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationCategoryDto {
        let result = new ApplicationCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationCategoryDto {
    name: string;
    nameEn: string;
    id: string;
}

export class PagedResultDtoOfApplicationCategoryDto implements IPagedResultDtoOfApplicationCategoryDto {
    totalCount: number;
    items: ApplicationCategoryDto[];

    constructor(data?: IPagedResultDtoOfApplicationCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApplicationCategoryDto {
        let result = new PagedResultDtoOfApplicationCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfApplicationCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfApplicationCategoryDto {
    totalCount: number;
    items: ApplicationCategoryDto[];
}

export class ApprovalRequestDto implements IApprovalRequestDto {
    type: string;
    title: string;
    dateRequested: moment.Moment;
    requestedBy: string;
    contentId: string;
    action: string;
    routeData: string;
    approvalStepId: string;
    approvalStepRoleId: string;
    isApproved: boolean;
    approvalAction: string;
    rejectionAction: string;
    id: string;

    constructor(data?: IApprovalRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.dateRequested = data["dateRequested"] ? moment(data["dateRequested"].toString()) : <any>undefined;
            this.requestedBy = data["requestedBy"];
            this.contentId = data["contentId"];
            this.action = data["action"];
            this.routeData = data["routeData"];
            this.approvalStepId = data["approvalStepId"];
            this.approvalStepRoleId = data["approvalStepRoleId"];
            this.isApproved = data["isApproved"];
            this.approvalAction = data["approvalAction"];
            this.rejectionAction = data["rejectionAction"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApprovalRequestDto {
        let result = new ApprovalRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["dateRequested"] = this.dateRequested ? this.dateRequested.toISOString() : <any>undefined;
        data["requestedBy"] = this.requestedBy;
        data["contentId"] = this.contentId;
        data["action"] = this.action;
        data["routeData"] = this.routeData;
        data["approvalStepId"] = this.approvalStepId;
        data["approvalStepRoleId"] = this.approvalStepRoleId;
        data["isApproved"] = this.isApproved;
        data["approvalAction"] = this.approvalAction;
        data["rejectionAction"] = this.rejectionAction;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApprovalRequestDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalRequestDto {
    type: string;
    title: string;
    dateRequested: moment.Moment;
    requestedBy: string;
    contentId: string;
    action: string;
    routeData: string;
    approvalStepId: string;
    approvalStepRoleId: string;
    isApproved: boolean;
    approvalAction: string;
    rejectionAction: string;
    id: string;
}

export class PagedResultDtoOfApprovalRequestDto implements IPagedResultDtoOfApprovalRequestDto {
    totalCount: number;
    items: ApprovalRequestDto[];

    constructor(data?: IPagedResultDtoOfApprovalRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApprovalRequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalRequestDto {
        let result = new PagedResultDtoOfApprovalRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfApprovalRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfApprovalRequestDto {
    totalCount: number;
    items: ApprovalRequestDto[];
}

export class ApprovalRequestStepDto implements IApprovalRequestStepDto {
    approvalRequestId: string;
    approvalRequestType: string;
    approvalStepId: string;
    approvalStepRoleId: string;
    isApproved: boolean;
    dateApproved: moment.Moment;
    approvedBy: string;
    comments: string;
    id: string;

    constructor(data?: IApprovalRequestStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvalRequestId = data["approvalRequestId"];
            this.approvalRequestType = data["approvalRequestType"];
            this.approvalStepId = data["approvalStepId"];
            this.approvalStepRoleId = data["approvalStepRoleId"];
            this.isApproved = data["isApproved"];
            this.dateApproved = data["dateApproved"] ? moment(data["dateApproved"].toString()) : <any>undefined;
            this.approvedBy = data["approvedBy"];
            this.comments = data["comments"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApprovalRequestStepDto {
        let result = new ApprovalRequestStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalRequestId"] = this.approvalRequestId;
        data["approvalRequestType"] = this.approvalRequestType;
        data["approvalStepId"] = this.approvalStepId;
        data["approvalStepRoleId"] = this.approvalStepRoleId;
        data["isApproved"] = this.isApproved;
        data["dateApproved"] = this.dateApproved ? this.dateApproved.toISOString() : <any>undefined;
        data["approvedBy"] = this.approvedBy;
        data["comments"] = this.comments;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApprovalRequestStepDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalRequestStepDto {
    approvalRequestId: string;
    approvalRequestType: string;
    approvalStepId: string;
    approvalStepRoleId: string;
    isApproved: boolean;
    dateApproved: moment.Moment;
    approvedBy: string;
    comments: string;
    id: string;
}

export class PagedResultDtoOfApprovalRequestStepDto implements IPagedResultDtoOfApprovalRequestStepDto {
    totalCount: number;
    items: ApprovalRequestStepDto[];

    constructor(data?: IPagedResultDtoOfApprovalRequestStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApprovalRequestStepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalRequestStepDto {
        let result = new PagedResultDtoOfApprovalRequestStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfApprovalRequestStepDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfApprovalRequestStepDto {
    totalCount: number;
    items: ApprovalRequestStepDto[];
}

export class ApprovalStepDto implements IApprovalStepDto {
    workflowId: string;
    order: number;
    roleId: string;
    groupId: string;
    isActive: boolean;
    id: string;

    constructor(data?: IApprovalStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workflowId = data["workflowId"];
            this.order = data["order"];
            this.roleId = data["roleId"];
            this.groupId = data["groupId"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApprovalStepDto {
        let result = new ApprovalStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["order"] = this.order;
        data["roleId"] = this.roleId;
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApprovalStepDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalStepDto {
    workflowId: string;
    order: number;
    roleId: string;
    groupId: string;
    isActive: boolean;
    id: string;
}

export class PagedResultDtoOfApprovalStepDto implements IPagedResultDtoOfApprovalStepDto {
    totalCount: number;
    items: ApprovalStepDto[];

    constructor(data?: IPagedResultDtoOfApprovalStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApprovalStepDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApprovalStepDto {
        let result = new PagedResultDtoOfApprovalStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfApprovalStepDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfApprovalStepDto {
    totalCount: number;
    items: ApprovalStepDto[];
}

export class AssetTypeDto implements IAssetTypeDto {
    name: string;
    isActive: boolean;
    id: string;

    constructor(data?: IAssetTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetTypeDto {
        let result = new AssetTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AssetTypeDto();
        result.init(json);
        return result;
    }
}

export interface IAssetTypeDto {
    name: string;
    isActive: boolean;
    id: string;
}

export class PagedResultDtoOfAssetTypeDto implements IPagedResultDtoOfAssetTypeDto {
    totalCount: number;
    items: AssetTypeDto[];

    constructor(data?: IPagedResultDtoOfAssetTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AssetTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetTypeDto {
        let result = new PagedResultDtoOfAssetTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAssetTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAssetTypeDto {
    totalCount: number;
    items: AssetTypeDto[];
}

export class CallBackResponseDto implements ICallBackResponseDto {
    responseId: string;
    surveyId: string;
    surveyName: string;
    userId: string;
    dateSubmitted: moment.Moment;
    parentResponseId: string;
    code: string;
    domainId: string;
    domainName: string;
    status: number;
    title: string;
    order: number;
    lastUpdateTime: moment.Moment;
    subCode: string;
    phaseId: string;
    phaseName: string;
    gisUniqueCode: string;
    isPrinted: boolean;
    sampleID: string;
    sampleCreateBy: string;
    resIdx: number;
    hvResponsesAnswer: boolean;
    similarityPercentage: number;
    correspondence: boolean;
    cbParentResponseId: string;
    cbParentResponseUserId: string;
    responseStatus: number;
    id: string;

    constructor(data?: ICallBackResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.responseId = data["responseId"];
            this.surveyId = data["surveyId"];
            this.surveyName = data["surveyName"];
            this.userId = data["userId"];
            this.dateSubmitted = data["dateSubmitted"] ? moment(data["dateSubmitted"].toString()) : <any>undefined;
            this.parentResponseId = data["parentResponseId"];
            this.code = data["code"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.status = data["status"];
            this.title = data["title"];
            this.order = data["order"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.subCode = data["subCode"];
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.gisUniqueCode = data["gisUniqueCode"];
            this.isPrinted = data["isPrinted"];
            this.sampleID = data["sampleID"];
            this.sampleCreateBy = data["sampleCreateBy"];
            this.resIdx = data["resIdx"];
            this.hvResponsesAnswer = data["hvResponsesAnswer"];
            this.similarityPercentage = data["similarityPercentage"];
            this.correspondence = data["correspondence"];
            this.cbParentResponseId = data["cbParentResponseId"];
            this.cbParentResponseUserId = data["cbParentResponseUserId"];
            this.responseStatus = data["responseStatus"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CallBackResponseDto {
        let result = new CallBackResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseId"] = this.responseId;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["userId"] = this.userId;
        data["dateSubmitted"] = this.dateSubmitted ? this.dateSubmitted.toISOString() : <any>undefined;
        data["parentResponseId"] = this.parentResponseId;
        data["code"] = this.code;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["status"] = this.status;
        data["title"] = this.title;
        data["order"] = this.order;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["subCode"] = this.subCode;
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["gisUniqueCode"] = this.gisUniqueCode;
        data["isPrinted"] = this.isPrinted;
        data["sampleID"] = this.sampleID;
        data["sampleCreateBy"] = this.sampleCreateBy;
        data["resIdx"] = this.resIdx;
        data["hvResponsesAnswer"] = this.hvResponsesAnswer;
        data["similarityPercentage"] = this.similarityPercentage;
        data["correspondence"] = this.correspondence;
        data["cbParentResponseId"] = this.cbParentResponseId;
        data["cbParentResponseUserId"] = this.cbParentResponseUserId;
        data["responseStatus"] = this.responseStatus;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CallBackResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICallBackResponseDto {
    responseId: string;
    surveyId: string;
    surveyName: string;
    userId: string;
    dateSubmitted: moment.Moment;
    parentResponseId: string;
    code: string;
    domainId: string;
    domainName: string;
    status: number;
    title: string;
    order: number;
    lastUpdateTime: moment.Moment;
    subCode: string;
    phaseId: string;
    phaseName: string;
    gisUniqueCode: string;
    isPrinted: boolean;
    sampleID: string;
    sampleCreateBy: string;
    resIdx: number;
    hvResponsesAnswer: boolean;
    similarityPercentage: number;
    correspondence: boolean;
    cbParentResponseId: string;
    cbParentResponseUserId: string;
    responseStatus: number;
    id: string;
}

export class PagedResultDtoOfCallBackResponseDto implements IPagedResultDtoOfCallBackResponseDto {
    totalCount: number;
    items: CallBackResponseDto[];

    constructor(data?: IPagedResultDtoOfCallBackResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CallBackResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCallBackResponseDto {
        let result = new PagedResultDtoOfCallBackResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCallBackResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCallBackResponseDto {
    totalCount: number;
    items: CallBackResponseDto[];
}

export class CommentDto implements ICommentDto {
    responseId: string;
    responseUserId: string;
    questionId: string;
    questionTitle: string;
    questionGroupId: string;
    questionGroupName: string;
    userId: string;
    userName: string;
    title: string;
    body: string;
    date: moment.Moment;
    id: string;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.responseId = data["responseId"];
            this.responseUserId = data["responseUserId"];
            this.questionId = data["questionId"];
            this.questionTitle = data["questionTitle"];
            this.questionGroupId = data["questionGroupId"];
            this.questionGroupName = data["questionGroupName"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.title = data["title"];
            this.body = data["body"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentDto {
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseId"] = this.responseId;
        data["responseUserId"] = this.responseUserId;
        data["questionId"] = this.questionId;
        data["questionTitle"] = this.questionTitle;
        data["questionGroupId"] = this.questionGroupId;
        data["questionGroupName"] = this.questionGroupName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["title"] = this.title;
        data["body"] = this.body;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CommentDto();
        result.init(json);
        return result;
    }
}

export interface ICommentDto {
    responseId: string;
    responseUserId: string;
    questionId: string;
    questionTitle: string;
    questionGroupId: string;
    questionGroupName: string;
    userId: string;
    userName: string;
    title: string;
    body: string;
    date: moment.Moment;
    id: string;
}

export class PagedResultDtoOfCommentDto implements IPagedResultDtoOfCommentDto {
    totalCount: number;
    items: CommentDto[];

    constructor(data?: IPagedResultDtoOfCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCommentDto {
        let result = new PagedResultDtoOfCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCommentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCommentDto {
    totalCount: number;
    items: CommentDto[];
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class DomainDto implements IDomainDto {
    name: string;
    code: string;
    parentDomainId: string;
    parentDomainName: string;
    domainGroupId: string;
    domainGroupName: string;
    ur: number;
    nameHierachy: string;
    id: string;

    constructor(data?: IDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.parentDomainId = data["parentDomainId"];
            this.parentDomainName = data["parentDomainName"];
            this.domainGroupId = data["domainGroupId"];
            this.domainGroupName = data["domainGroupName"];
            this.ur = data["ur"];
            this.nameHierachy = data["nameHierachy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainDto {
        let result = new DomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["parentDomainId"] = this.parentDomainId;
        data["parentDomainName"] = this.parentDomainName;
        data["domainGroupId"] = this.domainGroupId;
        data["domainGroupName"] = this.domainGroupName;
        data["ur"] = this.ur;
        data["nameHierachy"] = this.nameHierachy;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DomainDto();
        result.init(json);
        return result;
    }
}

export interface IDomainDto {
    name: string;
    code: string;
    parentDomainId: string;
    parentDomainName: string;
    domainGroupId: string;
    domainGroupName: string;
    ur: number;
    nameHierachy: string;
    id: string;
}

export class PagedResultDtoOfDomainDto implements IPagedResultDtoOfDomainDto {
    totalCount: number;
    items: DomainDto[];

    constructor(data?: IPagedResultDtoOfDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DomainDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDomainDto {
        let result = new PagedResultDtoOfDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDomainDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDomainDto {
    totalCount: number;
    items: DomainDto[];
}

export class DomainGroupDto implements IDomainGroupDto {
    name: string;
    type: number;
    subCategoryId: string;
    subCategoryName: string;
    isActive: boolean;
    createdDate: moment.Moment;
    lastUpdateTime: moment.Moment;
    id: string;

    constructor(data?: IDomainGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.subCategoryId = data["subCategoryId"];
            this.subCategoryName = data["subCategoryName"];
            this.isActive = data["isActive"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainGroupDto {
        let result = new DomainGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["subCategoryId"] = this.subCategoryId;
        data["subCategoryName"] = this.subCategoryName;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DomainGroupDto();
        result.init(json);
        return result;
    }
}

export interface IDomainGroupDto {
    name: string;
    type: number;
    subCategoryId: string;
    subCategoryName: string;
    isActive: boolean;
    createdDate: moment.Moment;
    lastUpdateTime: moment.Moment;
    id: string;
}

export class PagedResultDtoOfDomainGroupDto implements IPagedResultDtoOfDomainGroupDto {
    totalCount: number;
    items: DomainGroupDto[];

    constructor(data?: IPagedResultDtoOfDomainGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DomainGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDomainGroupDto {
        let result = new PagedResultDtoOfDomainGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDomainGroupDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDomainGroupDto {
    totalCount: number;
    items: DomainGroupDto[];
}

export class DomainGroupCategoryDto implements IDomainGroupCategoryDto {
    name: string;
    nameEn: string;
    type: number;
    isAdministrative: boolean;
    id: string;

    constructor(data?: IDomainGroupCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.type = data["type"];
            this.isAdministrative = data["isAdministrative"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainGroupCategoryDto {
        let result = new DomainGroupCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["type"] = this.type;
        data["isAdministrative"] = this.isAdministrative;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DomainGroupCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IDomainGroupCategoryDto {
    name: string;
    nameEn: string;
    type: number;
    isAdministrative: boolean;
    id: string;
}

export class PagedResultDtoOfDomainGroupCategoryDto implements IPagedResultDtoOfDomainGroupCategoryDto {
    totalCount: number;
    items: DomainGroupCategoryDto[];

    constructor(data?: IPagedResultDtoOfDomainGroupCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DomainGroupCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDomainGroupCategoryDto {
        let result = new PagedResultDtoOfDomainGroupCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDomainGroupCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDomainGroupCategoryDto {
    totalCount: number;
    items: DomainGroupCategoryDto[];
}

export class DomainGroupSubCategoryDto implements IDomainGroupSubCategoryDto {
    name: string;
    nameEn: string;
    domainGroupCategoryId: string;
    domainGroupCategoryName: string;
    id: string;

    constructor(data?: IDomainGroupSubCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.domainGroupCategoryId = data["domainGroupCategoryId"];
            this.domainGroupCategoryName = data["domainGroupCategoryName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainGroupSubCategoryDto {
        let result = new DomainGroupSubCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["domainGroupCategoryId"] = this.domainGroupCategoryId;
        data["domainGroupCategoryName"] = this.domainGroupCategoryName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DomainGroupSubCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IDomainGroupSubCategoryDto {
    name: string;
    nameEn: string;
    domainGroupCategoryId: string;
    domainGroupCategoryName: string;
    id: string;
}

export class PagedResultDtoOfDomainGroupSubCategoryDto implements IPagedResultDtoOfDomainGroupSubCategoryDto {
    totalCount: number;
    items: DomainGroupSubCategoryDto[];

    constructor(data?: IPagedResultDtoOfDomainGroupSubCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DomainGroupSubCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDomainGroupSubCategoryDto {
        let result = new PagedResultDtoOfDomainGroupSubCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDomainGroupSubCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDomainGroupSubCategoryDto {
    totalCount: number;
    items: DomainGroupSubCategoryDto[];
}

export class DomainSettingDto implements IDomainSettingDto {
    domainId: string;
    domainName: string;
    surveyId: string;
    surveyName: string;
    key: string;
    value: string;
    id: string;

    constructor(data?: IDomainSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.surveyId = data["surveyId"];
            this.surveyName = data["surveyName"];
            this.key = data["key"];
            this.value = data["value"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainSettingDto {
        let result = new DomainSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["key"] = this.key;
        data["value"] = this.value;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DomainSettingDto();
        result.init(json);
        return result;
    }
}

export interface IDomainSettingDto {
    domainId: string;
    domainName: string;
    surveyId: string;
    surveyName: string;
    key: string;
    value: string;
    id: string;
}

export class PagedResultDtoOfDomainSettingDto implements IPagedResultDtoOfDomainSettingDto {
    totalCount: number;
    items: DomainSettingDto[];

    constructor(data?: IPagedResultDtoOfDomainSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DomainSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDomainSettingDto {
        let result = new PagedResultDtoOfDomainSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDomainSettingDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDomainSettingDto {
    totalCount: number;
    items: DomainSettingDto[];
}

export class DomainTrainingCenterDto implements IDomainTrainingCenterDto {
    trainingCenterId: string;
    trainingCenterName: string;
    domainId: string;
    domainName: string;
    id: string;

    constructor(data?: IDomainTrainingCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingCenterId = data["trainingCenterId"];
            this.trainingCenterName = data["trainingCenterName"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DomainTrainingCenterDto {
        let result = new DomainTrainingCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingCenterId"] = this.trainingCenterId;
        data["trainingCenterName"] = this.trainingCenterName;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DomainTrainingCenterDto();
        result.init(json);
        return result;
    }
}

export interface IDomainTrainingCenterDto {
    trainingCenterId: string;
    trainingCenterName: string;
    domainId: string;
    domainName: string;
    id: string;
}

export class PagedResultDtoOfDomainTrainingCenterDto implements IPagedResultDtoOfDomainTrainingCenterDto {
    totalCount: number;
    items: DomainTrainingCenterDto[];

    constructor(data?: IPagedResultDtoOfDomainTrainingCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DomainTrainingCenterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDomainTrainingCenterDto {
        let result = new PagedResultDtoOfDomainTrainingCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDomainTrainingCenterDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDomainTrainingCenterDto {
    totalCount: number;
    items: DomainTrainingCenterDto[];
}

export class EncodingMapperQuestionDto implements IEncodingMapperQuestionDto {
    collectorQuestionId: string;
    encoderQuestionId: string;
    reviewerQuestionId: string;
    collectorDetailsQuestionId: string;
    id: number;

    constructor(data?: IEncodingMapperQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.collectorQuestionId = data["collectorQuestionId"];
            this.encoderQuestionId = data["encoderQuestionId"];
            this.reviewerQuestionId = data["reviewerQuestionId"];
            this.collectorDetailsQuestionId = data["collectorDetailsQuestionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EncodingMapperQuestionDto {
        let result = new EncodingMapperQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectorQuestionId"] = this.collectorQuestionId;
        data["encoderQuestionId"] = this.encoderQuestionId;
        data["reviewerQuestionId"] = this.reviewerQuestionId;
        data["collectorDetailsQuestionId"] = this.collectorDetailsQuestionId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EncodingMapperQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IEncodingMapperQuestionDto {
    collectorQuestionId: string;
    encoderQuestionId: string;
    reviewerQuestionId: string;
    collectorDetailsQuestionId: string;
    id: number;
}

export class PagedResultDtoOfEncodingMapperQuestionDto implements IPagedResultDtoOfEncodingMapperQuestionDto {
    totalCount: number;
    items: EncodingMapperQuestionDto[];

    constructor(data?: IPagedResultDtoOfEncodingMapperQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EncodingMapperQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEncodingMapperQuestionDto {
        let result = new PagedResultDtoOfEncodingMapperQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEncodingMapperQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEncodingMapperQuestionDto {
    totalCount: number;
    items: EncodingMapperQuestionDto[];
}

export class EncodingResponseDto implements IEncodingResponseDto {
    responseCode: string;
    surveyId: string;
    domainId: string;
    domainName: string;
    title: string;
    userName: string;
    coderId: string;
    coderName: string;
    dateCoded: moment.Moment;
    reviewerId: string;
    reviewerName: string;
    dateReviewed: moment.Moment;
    status: number;
    index: number;
    responseAnswers: string;
    id: string;

    constructor(data?: IEncodingResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.responseCode = data["responseCode"];
            this.surveyId = data["surveyId"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.title = data["title"];
            this.userName = data["userName"];
            this.coderId = data["coderId"];
            this.coderName = data["coderName"];
            this.dateCoded = data["dateCoded"] ? moment(data["dateCoded"].toString()) : <any>undefined;
            this.reviewerId = data["reviewerId"];
            this.reviewerName = data["reviewerName"];
            this.dateReviewed = data["dateReviewed"] ? moment(data["dateReviewed"].toString()) : <any>undefined;
            this.status = data["status"];
            this.index = data["index"];
            this.responseAnswers = data["responseAnswers"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EncodingResponseDto {
        let result = new EncodingResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseCode"] = this.responseCode;
        data["surveyId"] = this.surveyId;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["title"] = this.title;
        data["userName"] = this.userName;
        data["coderId"] = this.coderId;
        data["coderName"] = this.coderName;
        data["dateCoded"] = this.dateCoded ? this.dateCoded.toISOString() : <any>undefined;
        data["reviewerId"] = this.reviewerId;
        data["reviewerName"] = this.reviewerName;
        data["dateReviewed"] = this.dateReviewed ? this.dateReviewed.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["index"] = this.index;
        data["responseAnswers"] = this.responseAnswers;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EncodingResponseDto();
        result.init(json);
        return result;
    }
}

export interface IEncodingResponseDto {
    responseCode: string;
    surveyId: string;
    domainId: string;
    domainName: string;
    title: string;
    userName: string;
    coderId: string;
    coderName: string;
    dateCoded: moment.Moment;
    reviewerId: string;
    reviewerName: string;
    dateReviewed: moment.Moment;
    status: number;
    index: number;
    responseAnswers: string;
    id: string;
}

export class PagedResultDtoOfEncodingResponseDto implements IPagedResultDtoOfEncodingResponseDto {
    totalCount: number;
    items: EncodingResponseDto[];

    constructor(data?: IPagedResultDtoOfEncodingResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EncodingResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEncodingResponseDto {
        let result = new PagedResultDtoOfEncodingResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEncodingResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEncodingResponseDto {
    totalCount: number;
    items: EncodingResponseDto[];
}

export class ExamResultDto implements IExamResultDto {
    userId: string;
    questionnaireId: string;
    score: number;
    id: string;

    constructor(data?: IExamResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.questionnaireId = data["questionnaireId"];
            this.score = data["score"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ExamResultDto {
        let result = new ExamResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["questionnaireId"] = this.questionnaireId;
        data["score"] = this.score;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExamResultDto();
        result.init(json);
        return result;
    }
}

export interface IExamResultDto {
    userId: string;
    questionnaireId: string;
    score: number;
    id: string;
}

export class PagedResultDtoOfExamResultDto implements IPagedResultDtoOfExamResultDto {
    totalCount: number;
    items: ExamResultDto[];

    constructor(data?: IPagedResultDtoOfExamResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ExamResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExamResultDto {
        let result = new PagedResultDtoOfExamResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfExamResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfExamResultDto {
    totalCount: number;
    items: ExamResultDto[];
}

export class InspectionDto implements IInspectionDto {
    inspectorId: string;
    userId: string;
    date: moment.Moment;
    rating: number;
    comments: string;
    phaseId: string;
    phaseName: string;
    domainId: string;
    domainName: string;
    id: string;

    constructor(data?: IInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inspectorId = data["inspectorId"];
            this.userId = data["userId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.rating = data["rating"];
            this.comments = data["comments"];
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): InspectionDto {
        let result = new InspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectorId"] = this.inspectorId;
        data["userId"] = this.userId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["rating"] = this.rating;
        data["comments"] = this.comments;
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InspectionDto();
        result.init(json);
        return result;
    }
}

export interface IInspectionDto {
    inspectorId: string;
    userId: string;
    date: moment.Moment;
    rating: number;
    comments: string;
    phaseId: string;
    phaseName: string;
    domainId: string;
    domainName: string;
    id: string;
}

export class PagedResultDtoOfInspectionDto implements IPagedResultDtoOfInspectionDto {
    totalCount: number;
    items: InspectionDto[];

    constructor(data?: IPagedResultDtoOfInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(InspectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInspectionDto {
        let result = new PagedResultDtoOfInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfInspectionDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfInspectionDto {
    totalCount: number;
    items: InspectionDto[];
}

export class LocationTrackingDto implements ILocationTrackingDto {
    objectId: string;
    time: moment.Moment;
    isInArea: boolean;
    isLast: boolean;
    id: string;

    constructor(data?: ILocationTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.objectId = data["objectId"];
            this.time = data["time"] ? moment(data["time"].toString()) : <any>undefined;
            this.isInArea = data["isInArea"];
            this.isLast = data["isLast"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LocationTrackingDto {
        let result = new LocationTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["isInArea"] = this.isInArea;
        data["isLast"] = this.isLast;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LocationTrackingDto();
        result.init(json);
        return result;
    }
}

export interface ILocationTrackingDto {
    objectId: string;
    time: moment.Moment;
    isInArea: boolean;
    isLast: boolean;
    id: string;
}

export class PagedResultDtoOfLocationTrackingDto implements IPagedResultDtoOfLocationTrackingDto {
    totalCount: number;
    items: LocationTrackingDto[];

    constructor(data?: IPagedResultDtoOfLocationTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocationTrackingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLocationTrackingDto {
        let result = new PagedResultDtoOfLocationTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLocationTrackingDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLocationTrackingDto {
    totalCount: number;
    items: LocationTrackingDto[];
}

export class LogDto implements ILogDto {
    actionTypeId: number;
    actionDate: moment.Moment;
    createdById: string;
    userId: string;
    domainsIds: string;
    domainsNames: string;
    properties: string;
    id: string;

    constructor(data?: ILogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionTypeId = data["actionTypeId"];
            this.actionDate = data["actionDate"] ? moment(data["actionDate"].toString()) : <any>undefined;
            this.createdById = data["createdById"];
            this.userId = data["userId"];
            this.domainsIds = data["domainsIds"];
            this.domainsNames = data["domainsNames"];
            this.properties = data["properties"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LogDto {
        let result = new LogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionTypeId"] = this.actionTypeId;
        data["actionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["userId"] = this.userId;
        data["domainsIds"] = this.domainsIds;
        data["domainsNames"] = this.domainsNames;
        data["properties"] = this.properties;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LogDto();
        result.init(json);
        return result;
    }
}

export interface ILogDto {
    actionTypeId: number;
    actionDate: moment.Moment;
    createdById: string;
    userId: string;
    domainsIds: string;
    domainsNames: string;
    properties: string;
    id: string;
}

export class PagedResultDtoOfLogDto implements IPagedResultDtoOfLogDto {
    totalCount: number;
    items: LogDto[];

    constructor(data?: IPagedResultDtoOfLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLogDto {
        let result = new PagedResultDtoOfLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLogDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLogDto {
    totalCount: number;
    items: LogDto[];
}

export class LogActionTypeDto implements ILogActionTypeDto {
    name: string;
    id: number;

    constructor(data?: ILogActionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LogActionTypeDto {
        let result = new LogActionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LogActionTypeDto();
        result.init(json);
        return result;
    }
}

export interface ILogActionTypeDto {
    name: string;
    id: number;
}

export class PagedResultDtoOfLogActionTypeDto implements IPagedResultDtoOfLogActionTypeDto {
    totalCount: number;
    items: LogActionTypeDto[];

    constructor(data?: IPagedResultDtoOfLogActionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LogActionTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLogActionTypeDto {
        let result = new PagedResultDtoOfLogActionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLogActionTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLogActionTypeDto {
    totalCount: number;
    items: LogActionTypeDto[];
}

export class OnlineRegistrationResponseDto implements IOnlineRegistrationResponseDto {
    nationalId: string;
    phoneNumber: string;
    code: string;
    unitType: string;
    id: string;

    constructor(data?: IOnlineRegistrationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nationalId = data["nationalId"];
            this.phoneNumber = data["phoneNumber"];
            this.code = data["code"];
            this.unitType = data["unitType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OnlineRegistrationResponseDto {
        let result = new OnlineRegistrationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationalId"] = this.nationalId;
        data["phoneNumber"] = this.phoneNumber;
        data["code"] = this.code;
        data["unitType"] = this.unitType;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new OnlineRegistrationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IOnlineRegistrationResponseDto {
    nationalId: string;
    phoneNumber: string;
    code: string;
    unitType: string;
    id: string;
}

export class PagedResultDtoOfOnlineRegistrationResponseDto implements IPagedResultDtoOfOnlineRegistrationResponseDto {
    totalCount: number;
    items: OnlineRegistrationResponseDto[];

    constructor(data?: IPagedResultDtoOfOnlineRegistrationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OnlineRegistrationResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOnlineRegistrationResponseDto {
        let result = new PagedResultDtoOfOnlineRegistrationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOnlineRegistrationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOnlineRegistrationResponseDto {
    totalCount: number;
    items: OnlineRegistrationResponseDto[];
}

export class PhaseDto implements IPhaseDto {
    name: string;
    applicationId: string;
    applicationName: string;
    from: moment.Moment;
    to: moment.Moment;
    order: number;
    isActive: boolean;
    baseDomainGroupId: string;
    baseDomainGroupName: string;
    domainGroupId: string;
    domainGroupName: string;
    defaultSurveyId: string;
    id: string;

    constructor(data?: IPhaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.applicationId = data["applicationId"];
            this.applicationName = data["applicationName"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            this.order = data["order"];
            this.isActive = data["isActive"];
            this.baseDomainGroupId = data["baseDomainGroupId"];
            this.baseDomainGroupName = data["baseDomainGroupName"];
            this.domainGroupId = data["domainGroupId"];
            this.domainGroupName = data["domainGroupName"];
            this.defaultSurveyId = data["defaultSurveyId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PhaseDto {
        let result = new PhaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["applicationId"] = this.applicationId;
        data["applicationName"] = this.applicationName;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["baseDomainGroupId"] = this.baseDomainGroupId;
        data["baseDomainGroupName"] = this.baseDomainGroupName;
        data["domainGroupId"] = this.domainGroupId;
        data["domainGroupName"] = this.domainGroupName;
        data["defaultSurveyId"] = this.defaultSurveyId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PhaseDto();
        result.init(json);
        return result;
    }
}

export interface IPhaseDto {
    name: string;
    applicationId: string;
    applicationName: string;
    from: moment.Moment;
    to: moment.Moment;
    order: number;
    isActive: boolean;
    baseDomainGroupId: string;
    baseDomainGroupName: string;
    domainGroupId: string;
    domainGroupName: string;
    defaultSurveyId: string;
    id: string;
}

export class PagedResultDtoOfPhaseDto implements IPagedResultDtoOfPhaseDto {
    totalCount: number;
    items: PhaseDto[];

    constructor(data?: IPagedResultDtoOfPhaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPhaseDto {
        let result = new PagedResultDtoOfPhaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPhaseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPhaseDto {
    totalCount: number;
    items: PhaseDto[];
}

export class PhaseQuestionDto implements IPhaseQuestionDto {
    phaseId: string;
    phaseName: string;
    questionId: string;
    questionTitle: string;
    id: string;

    constructor(data?: IPhaseQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.questionId = data["questionId"];
            this.questionTitle = data["questionTitle"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PhaseQuestionDto {
        let result = new PhaseQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["questionId"] = this.questionId;
        data["questionTitle"] = this.questionTitle;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PhaseQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IPhaseQuestionDto {
    phaseId: string;
    phaseName: string;
    questionId: string;
    questionTitle: string;
    id: string;
}

export class PagedResultDtoOfPhaseQuestionDto implements IPagedResultDtoOfPhaseQuestionDto {
    totalCount: number;
    items: PhaseQuestionDto[];

    constructor(data?: IPagedResultDtoOfPhaseQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhaseQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPhaseQuestionDto {
        let result = new PagedResultDtoOfPhaseQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPhaseQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPhaseQuestionDto {
    totalCount: number;
    items: PhaseQuestionDto[];
}

export class PhaseSurveyDto implements IPhaseSurveyDto {
    phaseId: string;
    phaseName: string;
    surveyId: string;
    surveyName: string;
    id: string;

    constructor(data?: IPhaseSurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.surveyId = data["surveyId"];
            this.surveyName = data["surveyName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PhaseSurveyDto {
        let result = new PhaseSurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PhaseSurveyDto();
        result.init(json);
        return result;
    }
}

export interface IPhaseSurveyDto {
    phaseId: string;
    phaseName: string;
    surveyId: string;
    surveyName: string;
    id: string;
}

export class PagedResultDtoOfPhaseSurveyDto implements IPagedResultDtoOfPhaseSurveyDto {
    totalCount: number;
    items: PhaseSurveyDto[];

    constructor(data?: IPagedResultDtoOfPhaseSurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhaseSurveyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPhaseSurveyDto {
        let result = new PagedResultDtoOfPhaseSurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPhaseSurveyDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPhaseSurveyDto {
    totalCount: number;
    items: PhaseSurveyDto[];
}

export class QualityCallBackResponseDto implements IQualityCallBackResponseDto {
    responseId: string;
    surveyId: string;
    userId: string;
    parentResponseId: string;
    startTime: moment.Moment;
    endTime: moment.Moment;
    code: string;
    domainId: string;
    status: number;
    title: string;
    lastUpdateTime: moment.Moment;
    isReal: boolean;
    phaseId: string;
    creationPhaseId: string;
    skipReason: number;
    skipComment: string;
    calledByCallCenter: number;
    callCenterComment: string;
    similarityPercentage: number;
    id: number;

    constructor(data?: IQualityCallBackResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.responseId = data["responseId"];
            this.surveyId = data["surveyId"];
            this.userId = data["userId"];
            this.parentResponseId = data["parentResponseId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.code = data["code"];
            this.domainId = data["domainId"];
            this.status = data["status"];
            this.title = data["title"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.isReal = data["isReal"];
            this.phaseId = data["phaseId"];
            this.creationPhaseId = data["creationPhaseId"];
            this.skipReason = data["skipReason"];
            this.skipComment = data["skipComment"];
            this.calledByCallCenter = data["calledByCallCenter"];
            this.callCenterComment = data["callCenterComment"];
            this.similarityPercentage = data["similarityPercentage"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QualityCallBackResponseDto {
        let result = new QualityCallBackResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseId"] = this.responseId;
        data["surveyId"] = this.surveyId;
        data["userId"] = this.userId;
        data["parentResponseId"] = this.parentResponseId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["domainId"] = this.domainId;
        data["status"] = this.status;
        data["title"] = this.title;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["isReal"] = this.isReal;
        data["phaseId"] = this.phaseId;
        data["creationPhaseId"] = this.creationPhaseId;
        data["skipReason"] = this.skipReason;
        data["skipComment"] = this.skipComment;
        data["calledByCallCenter"] = this.calledByCallCenter;
        data["callCenterComment"] = this.callCenterComment;
        data["similarityPercentage"] = this.similarityPercentage;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QualityCallBackResponseDto();
        result.init(json);
        return result;
    }
}

export interface IQualityCallBackResponseDto {
    responseId: string;
    surveyId: string;
    userId: string;
    parentResponseId: string;
    startTime: moment.Moment;
    endTime: moment.Moment;
    code: string;
    domainId: string;
    status: number;
    title: string;
    lastUpdateTime: moment.Moment;
    isReal: boolean;
    phaseId: string;
    creationPhaseId: string;
    skipReason: number;
    skipComment: string;
    calledByCallCenter: number;
    callCenterComment: string;
    similarityPercentage: number;
    id: number;
}

export class PagedResultDtoOfQualityCallBackResponseDto implements IPagedResultDtoOfQualityCallBackResponseDto {
    totalCount: number;
    items: QualityCallBackResponseDto[];

    constructor(data?: IPagedResultDtoOfQualityCallBackResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QualityCallBackResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQualityCallBackResponseDto {
        let result = new PagedResultDtoOfQualityCallBackResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQualityCallBackResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQualityCallBackResponseDto {
    totalCount: number;
    items: QualityCallBackResponseDto[];
}

export class QualityCallBackResponseAnswerDto implements IQualityCallBackResponseAnswerDto {
    responseAnswerId: string;
    questionId: string;
    questionAnswerId: string;
    answerValue: string;
    answerNumber: number;
    answerTime: moment.Moment;
    responseId: string;
    status: number;
    id: number;

    constructor(data?: IQualityCallBackResponseAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.responseAnswerId = data["responseAnswerId"];
            this.questionId = data["questionId"];
            this.questionAnswerId = data["questionAnswerId"];
            this.answerValue = data["answerValue"];
            this.answerNumber = data["answerNumber"];
            this.answerTime = data["answerTime"] ? moment(data["answerTime"].toString()) : <any>undefined;
            this.responseId = data["responseId"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QualityCallBackResponseAnswerDto {
        let result = new QualityCallBackResponseAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseAnswerId"] = this.responseAnswerId;
        data["questionId"] = this.questionId;
        data["questionAnswerId"] = this.questionAnswerId;
        data["answerValue"] = this.answerValue;
        data["answerNumber"] = this.answerNumber;
        data["answerTime"] = this.answerTime ? this.answerTime.toISOString() : <any>undefined;
        data["responseId"] = this.responseId;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QualityCallBackResponseAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IQualityCallBackResponseAnswerDto {
    responseAnswerId: string;
    questionId: string;
    questionAnswerId: string;
    answerValue: string;
    answerNumber: number;
    answerTime: moment.Moment;
    responseId: string;
    status: number;
    id: number;
}

export class PagedResultDtoOfQualityCallBackResponseAnswerDto implements IPagedResultDtoOfQualityCallBackResponseAnswerDto {
    totalCount: number;
    items: QualityCallBackResponseAnswerDto[];

    constructor(data?: IPagedResultDtoOfQualityCallBackResponseAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QualityCallBackResponseAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQualityCallBackResponseAnswerDto {
        let result = new PagedResultDtoOfQualityCallBackResponseAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQualityCallBackResponseAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQualityCallBackResponseAnswerDto {
    totalCount: number;
    items: QualityCallBackResponseAnswerDto[];
}

export class QuestionDto implements IQuestionDto {
    title: string;
    isActive: boolean;
    order: number;
    questionType: number;
    domainGroupId: string;
    domainGroupName: string;
    domainGroupLevelsNumber: number;
    questionGroupId: string;
    questionGroupName: string;
    code: string;
    isRequired: boolean;
    isHidden: boolean;
    description: string;
    questionNumber: string;
    help: string;
    defaultAnswerValue: string;
    isUsedInCallBack: boolean;
    isUsedInEncoding: boolean;
    questionAnswers: QuestionAnswerDto[];
    validationRules: ValidationRuleDto[];
    id: string;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.questionType = data["questionType"];
            this.domainGroupId = data["domainGroupId"];
            this.domainGroupName = data["domainGroupName"];
            this.domainGroupLevelsNumber = data["domainGroupLevelsNumber"];
            this.questionGroupId = data["questionGroupId"];
            this.questionGroupName = data["questionGroupName"];
            this.code = data["code"];
            this.isRequired = data["isRequired"];
            this.isHidden = data["isHidden"];
            this.description = data["description"];
            this.questionNumber = data["questionNumber"];
            this.help = data["help"];
            this.defaultAnswerValue = data["defaultAnswerValue"];
            this.isUsedInCallBack = data["isUsedInCallBack"];
            this.isUsedInEncoding = data["isUsedInEncoding"];
            if (data["questionAnswers"] && data["questionAnswers"].constructor === Array) {
                this.questionAnswers = [];
                for (let item of data["questionAnswers"])
                    this.questionAnswers.push(QuestionAnswerDto.fromJS(item));
            }
            if (data["validationRules"] && data["validationRules"].constructor === Array) {
                this.validationRules = [];
                for (let item of data["validationRules"])
                    this.validationRules.push(ValidationRuleDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionDto {
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["questionType"] = this.questionType;
        data["domainGroupId"] = this.domainGroupId;
        data["domainGroupName"] = this.domainGroupName;
        data["domainGroupLevelsNumber"] = this.domainGroupLevelsNumber;
        data["questionGroupId"] = this.questionGroupId;
        data["questionGroupName"] = this.questionGroupName;
        data["code"] = this.code;
        data["isRequired"] = this.isRequired;
        data["isHidden"] = this.isHidden;
        data["description"] = this.description;
        data["questionNumber"] = this.questionNumber;
        data["help"] = this.help;
        data["defaultAnswerValue"] = this.defaultAnswerValue;
        data["isUsedInCallBack"] = this.isUsedInCallBack;
        data["isUsedInEncoding"] = this.isUsedInEncoding;
        if (this.questionAnswers && this.questionAnswers.constructor === Array) {
            data["questionAnswers"] = [];
            for (let item of this.questionAnswers)
                data["questionAnswers"].push(item.toJSON());
        }
        if (this.validationRules && this.validationRules.constructor === Array) {
            data["validationRules"] = [];
            for (let item of this.validationRules)
                data["validationRules"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionDto {
    title: string;
    isActive: boolean;
    order: number;
    questionType: number;
    domainGroupId: string;
    domainGroupName: string;
    domainGroupLevelsNumber: number;
    questionGroupId: string;
    questionGroupName: string;
    code: string;
    isRequired: boolean;
    isHidden: boolean;
    description: string;
    questionNumber: string;
    help: string;
    defaultAnswerValue: string;
    isUsedInCallBack: boolean;
    isUsedInEncoding: boolean;
    questionAnswers: QuestionAnswerDto[];
    validationRules: ValidationRuleDto[];
    id: string;
}

export class QuestionAnswerDto implements IQuestionAnswerDto {
    title: string;
    isActive: boolean;
    order: number;
    code: string;
    allowText: boolean;
    id: string;

    constructor(data?: IQuestionAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.code = data["code"];
            this.allowText = data["allowText"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionAnswerDto {
        let result = new QuestionAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["code"] = this.code;
        data["allowText"] = this.allowText;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionAnswerDto {
    title: string;
    isActive: boolean;
    order: number;
    code: string;
    allowText: boolean;
    id: string;
}

export class ValidationRuleDto implements IValidationRuleDto {
    questionGroupId: string;
    answers: string;
    dependentQuestionId: string;
    dependentAnswers: string;
    dependentQuestions: string;
    ruleType: number;
    errorMessage: string;
    isActive: boolean;
    id: string;

    constructor(data?: IValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionGroupId = data["questionGroupId"];
            this.answers = data["answers"];
            this.dependentQuestionId = data["dependentQuestionId"];
            this.dependentAnswers = data["dependentAnswers"];
            this.dependentQuestions = data["dependentQuestions"];
            this.ruleType = data["ruleType"];
            this.errorMessage = data["errorMessage"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ValidationRuleDto {
        let result = new ValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionGroupId"] = this.questionGroupId;
        data["answers"] = this.answers;
        data["dependentQuestionId"] = this.dependentQuestionId;
        data["dependentAnswers"] = this.dependentAnswers;
        data["dependentQuestions"] = this.dependentQuestions;
        data["ruleType"] = this.ruleType;
        data["errorMessage"] = this.errorMessage;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ValidationRuleDto();
        result.init(json);
        return result;
    }
}

export interface IValidationRuleDto {
    questionGroupId: string;
    answers: string;
    dependentQuestionId: string;
    dependentAnswers: string;
    dependentQuestions: string;
    ruleType: number;
    errorMessage: string;
    isActive: boolean;
    id: string;
}

export class PagedResultDtoOfQuestionDto implements IPagedResultDtoOfQuestionDto {
    totalCount: number;
    items: QuestionDto[];

    constructor(data?: IPagedResultDtoOfQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionDto {
        let result = new PagedResultDtoOfQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionDto {
    totalCount: number;
    items: QuestionDto[];
}

export class QuestionAttachmentDto implements IQuestionAttachmentDto {
    name: string;
    description: string;
    path: string;
    order: number;
    questionId: string;
    questionTitle: string;
    type: number;
    id: string;

    constructor(data?: IQuestionAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.path = data["path"];
            this.order = data["order"];
            this.questionId = data["questionId"];
            this.questionTitle = data["questionTitle"];
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionAttachmentDto {
        let result = new QuestionAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["path"] = this.path;
        data["order"] = this.order;
        data["questionId"] = this.questionId;
        data["questionTitle"] = this.questionTitle;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionAttachmentDto {
    name: string;
    description: string;
    path: string;
    order: number;
    questionId: string;
    questionTitle: string;
    type: number;
    id: string;
}

export class PagedResultDtoOfQuestionAttachmentDto implements IPagedResultDtoOfQuestionAttachmentDto {
    totalCount: number;
    items: QuestionAttachmentDto[];

    constructor(data?: IPagedResultDtoOfQuestionAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionAttachmentDto {
        let result = new PagedResultDtoOfQuestionAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionAttachmentDto {
    totalCount: number;
    items: QuestionAttachmentDto[];
}

export class QuestionGroupDto implements IQuestionGroupDto {
    name: string;
    isActive: boolean;
    order: number;
    surveyId: string;
    surveyName: string;
    code: string;
    description: string;
    descriptionEnglish: string;
    id: string;

    constructor(data?: IQuestionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.surveyId = data["surveyId"];
            this.surveyName = data["surveyName"];
            this.code = data["code"];
            this.description = data["description"];
            this.descriptionEnglish = data["descriptionEnglish"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionGroupDto {
        let result = new QuestionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["code"] = this.code;
        data["description"] = this.description;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionGroupDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionGroupDto {
    name: string;
    isActive: boolean;
    order: number;
    surveyId: string;
    surveyName: string;
    code: string;
    description: string;
    descriptionEnglish: string;
    id: string;
}

export class PagedResultDtoOfQuestionGroupDto implements IPagedResultDtoOfQuestionGroupDto {
    totalCount: number;
    items: QuestionGroupDto[];

    constructor(data?: IPagedResultDtoOfQuestionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionGroupDto {
        let result = new PagedResultDtoOfQuestionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionGroupDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionGroupDto {
    totalCount: number;
    items: QuestionGroupDto[];
}

export class QuestionnaireDto implements IQuestionnaireDto {
    title: string;
    description: string;
    type: number;
    createdDate: moment.Moment;
    phaseId: string;
    phaseName: string;
    isActive: boolean;
    questionsCount: number;
    id: string;

    constructor(data?: IQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.description = data["description"];
            this.type = data["type"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.isActive = data["isActive"];
            this.questionsCount = data["questionsCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionnaireDto {
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["type"] = this.type;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["isActive"] = this.isActive;
        data["questionsCount"] = this.questionsCount;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireDto {
    title: string;
    description: string;
    type: number;
    createdDate: moment.Moment;
    phaseId: string;
    phaseName: string;
    isActive: boolean;
    questionsCount: number;
    id: string;
}

export class PagedResultDtoOfQuestionnaireDto implements IPagedResultDtoOfQuestionnaireDto {
    totalCount: number;
    items: QuestionnaireDto[];

    constructor(data?: IPagedResultDtoOfQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionnaireDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionnaireDto {
        let result = new PagedResultDtoOfQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionnaireDto {
    totalCount: number;
    items: QuestionnaireDto[];
}

export class QuestionnaireExamResultDto implements IQuestionnaireExamResultDto {
    userId: string;
    questionnaireId: string;
    questionnaireTitle: string;
    userScore: number;
    totalScore: number;
    submitDate: moment.Moment;
    id: string;

    constructor(data?: IQuestionnaireExamResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.questionnaireId = data["questionnaireId"];
            this.questionnaireTitle = data["questionnaireTitle"];
            this.userScore = data["userScore"];
            this.totalScore = data["totalScore"];
            this.submitDate = data["submitDate"] ? moment(data["submitDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionnaireExamResultDto {
        let result = new QuestionnaireExamResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["questionnaireId"] = this.questionnaireId;
        data["questionnaireTitle"] = this.questionnaireTitle;
        data["userScore"] = this.userScore;
        data["totalScore"] = this.totalScore;
        data["submitDate"] = this.submitDate ? this.submitDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionnaireExamResultDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireExamResultDto {
    userId: string;
    questionnaireId: string;
    questionnaireTitle: string;
    userScore: number;
    totalScore: number;
    submitDate: moment.Moment;
    id: string;
}

export class PagedResultDtoOfQuestionnaireExamResultDto implements IPagedResultDtoOfQuestionnaireExamResultDto {
    totalCount: number;
    items: QuestionnaireExamResultDto[];

    constructor(data?: IPagedResultDtoOfQuestionnaireExamResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionnaireExamResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionnaireExamResultDto {
        let result = new PagedResultDtoOfQuestionnaireExamResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionnaireExamResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionnaireExamResultDto {
    totalCount: number;
    items: QuestionnaireExamResultDto[];
}

export class QuestionnaireQuestionDto implements IQuestionnaireQuestionDto {
    title: string;
    brief: string;
    questionnaireId: string;
    questionnaireTitle: string;
    answerType: number;
    score: number;
    order: number;
    id: string;

    constructor(data?: IQuestionnaireQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.brief = data["brief"];
            this.questionnaireId = data["questionnaireId"];
            this.questionnaireTitle = data["questionnaireTitle"];
            this.answerType = data["answerType"];
            this.score = data["score"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionnaireQuestionDto {
        let result = new QuestionnaireQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["brief"] = this.brief;
        data["questionnaireId"] = this.questionnaireId;
        data["questionnaireTitle"] = this.questionnaireTitle;
        data["answerType"] = this.answerType;
        data["score"] = this.score;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionnaireQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireQuestionDto {
    title: string;
    brief: string;
    questionnaireId: string;
    questionnaireTitle: string;
    answerType: number;
    score: number;
    order: number;
    id: string;
}

export class PagedResultDtoOfQuestionnaireQuestionDto implements IPagedResultDtoOfQuestionnaireQuestionDto {
    totalCount: number;
    items: QuestionnaireQuestionDto[];

    constructor(data?: IPagedResultDtoOfQuestionnaireQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionnaireQuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionnaireQuestionDto {
        let result = new PagedResultDtoOfQuestionnaireQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionnaireQuestionDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionnaireQuestionDto {
    totalCount: number;
    items: QuestionnaireQuestionDto[];
}

export class QuestionnaireQuestionAnswerDto implements IQuestionnaireQuestionAnswerDto {
    title: string;
    questionId: string;
    questionTitle: string;
    isTrue: boolean;
    order: number;
    id: string;

    constructor(data?: IQuestionnaireQuestionAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.questionId = data["questionId"];
            this.questionTitle = data["questionTitle"];
            this.isTrue = data["isTrue"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionnaireQuestionAnswerDto {
        let result = new QuestionnaireQuestionAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["questionId"] = this.questionId;
        data["questionTitle"] = this.questionTitle;
        data["isTrue"] = this.isTrue;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionnaireQuestionAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireQuestionAnswerDto {
    title: string;
    questionId: string;
    questionTitle: string;
    isTrue: boolean;
    order: number;
    id: string;
}

export class PagedResultDtoOfQuestionnaireQuestionAnswerDto implements IPagedResultDtoOfQuestionnaireQuestionAnswerDto {
    totalCount: number;
    items: QuestionnaireQuestionAnswerDto[];

    constructor(data?: IPagedResultDtoOfQuestionnaireQuestionAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionnaireQuestionAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionnaireQuestionAnswerDto {
        let result = new PagedResultDtoOfQuestionnaireQuestionAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionnaireQuestionAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionnaireQuestionAnswerDto {
    totalCount: number;
    items: QuestionnaireQuestionAnswerDto[];
}

export class QuestionnaireQuestionAttachmentDto implements IQuestionnaireQuestionAttachmentDto {
    name: string;
    description: string;
    path: string;
    order: number;
    questionId: string;
    questionTitle: string;
    type: number;
    id: string;

    constructor(data?: IQuestionnaireQuestionAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.path = data["path"];
            this.order = data["order"];
            this.questionId = data["questionId"];
            this.questionTitle = data["questionTitle"];
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionnaireQuestionAttachmentDto {
        let result = new QuestionnaireQuestionAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["path"] = this.path;
        data["order"] = this.order;
        data["questionId"] = this.questionId;
        data["questionTitle"] = this.questionTitle;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionnaireQuestionAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireQuestionAttachmentDto {
    name: string;
    description: string;
    path: string;
    order: number;
    questionId: string;
    questionTitle: string;
    type: number;
    id: string;
}

export class PagedResultDtoOfQuestionnaireQuestionAttachmentDto implements IPagedResultDtoOfQuestionnaireQuestionAttachmentDto {
    totalCount: number;
    items: QuestionnaireQuestionAttachmentDto[];

    constructor(data?: IPagedResultDtoOfQuestionnaireQuestionAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionnaireQuestionAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionnaireQuestionAttachmentDto {
        let result = new PagedResultDtoOfQuestionnaireQuestionAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionnaireQuestionAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionnaireQuestionAttachmentDto {
    totalCount: number;
    items: QuestionnaireQuestionAttachmentDto[];
}

export class QuestionTemplateDto implements IQuestionTemplateDto {
    questionTemplateSubCategoryId: string;
    questionTemplateSubCategoryName: string;
    name: string;
    nameEn: string;
    type: number;
    code: string;
    isRequired: boolean;
    description: string;
    descriptionEn: string;
    help: string;
    helpEn: string;
    domainGroupId: string;
    domainGroupLevelsNumber: number;
    order: number;
    id: string;

    constructor(data?: IQuestionTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionTemplateSubCategoryId = data["questionTemplateSubCategoryId"];
            this.questionTemplateSubCategoryName = data["questionTemplateSubCategoryName"];
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.type = data["type"];
            this.code = data["code"];
            this.isRequired = data["isRequired"];
            this.description = data["description"];
            this.descriptionEn = data["descriptionEn"];
            this.help = data["help"];
            this.helpEn = data["helpEn"];
            this.domainGroupId = data["domainGroupId"];
            this.domainGroupLevelsNumber = data["domainGroupLevelsNumber"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionTemplateDto {
        let result = new QuestionTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionTemplateSubCategoryId"] = this.questionTemplateSubCategoryId;
        data["questionTemplateSubCategoryName"] = this.questionTemplateSubCategoryName;
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["type"] = this.type;
        data["code"] = this.code;
        data["isRequired"] = this.isRequired;
        data["description"] = this.description;
        data["descriptionEn"] = this.descriptionEn;
        data["help"] = this.help;
        data["helpEn"] = this.helpEn;
        data["domainGroupId"] = this.domainGroupId;
        data["domainGroupLevelsNumber"] = this.domainGroupLevelsNumber;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionTemplateDto {
    questionTemplateSubCategoryId: string;
    questionTemplateSubCategoryName: string;
    name: string;
    nameEn: string;
    type: number;
    code: string;
    isRequired: boolean;
    description: string;
    descriptionEn: string;
    help: string;
    helpEn: string;
    domainGroupId: string;
    domainGroupLevelsNumber: number;
    order: number;
    id: string;
}

export class PagedResultDtoOfQuestionTemplateDto implements IPagedResultDtoOfQuestionTemplateDto {
    totalCount: number;
    items: QuestionTemplateDto[];

    constructor(data?: IPagedResultDtoOfQuestionTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionTemplateDto {
        let result = new PagedResultDtoOfQuestionTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionTemplateDto {
    totalCount: number;
    items: QuestionTemplateDto[];
}

export class QuestionTemplateAnswerDto implements IQuestionTemplateAnswerDto {
    questionTemplateId: string;
    questionTemplateName: string;
    name: string;
    nameEn: string;
    code: string;
    order: number;
    id: string;

    constructor(data?: IQuestionTemplateAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionTemplateId = data["questionTemplateId"];
            this.questionTemplateName = data["questionTemplateName"];
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.code = data["code"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionTemplateAnswerDto {
        let result = new QuestionTemplateAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionTemplateId"] = this.questionTemplateId;
        data["questionTemplateName"] = this.questionTemplateName;
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["code"] = this.code;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionTemplateAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionTemplateAnswerDto {
    questionTemplateId: string;
    questionTemplateName: string;
    name: string;
    nameEn: string;
    code: string;
    order: number;
    id: string;
}

export class PagedResultDtoOfQuestionTemplateAnswerDto implements IPagedResultDtoOfQuestionTemplateAnswerDto {
    totalCount: number;
    items: QuestionTemplateAnswerDto[];

    constructor(data?: IPagedResultDtoOfQuestionTemplateAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionTemplateAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionTemplateAnswerDto {
        let result = new PagedResultDtoOfQuestionTemplateAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionTemplateAnswerDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionTemplateAnswerDto {
    totalCount: number;
    items: QuestionTemplateAnswerDto[];
}

export class QuestionTemplateCategoryDto implements IQuestionTemplateCategoryDto {
    name: string;
    nameEn: string;
    id: string;

    constructor(data?: IQuestionTemplateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionTemplateCategoryDto {
        let result = new QuestionTemplateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionTemplateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionTemplateCategoryDto {
    name: string;
    nameEn: string;
    id: string;
}

export class PagedResultDtoOfQuestionTemplateCategoryDto implements IPagedResultDtoOfQuestionTemplateCategoryDto {
    totalCount: number;
    items: QuestionTemplateCategoryDto[];

    constructor(data?: IPagedResultDtoOfQuestionTemplateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionTemplateCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionTemplateCategoryDto {
        let result = new PagedResultDtoOfQuestionTemplateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionTemplateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionTemplateCategoryDto {
    totalCount: number;
    items: QuestionTemplateCategoryDto[];
}

export class QuestionTemplateSubCategoryDto implements IQuestionTemplateSubCategoryDto {
    questionTemplateCategoryId: string;
    questionTemplateCategoryName: string;
    name: string;
    nameEn: string;
    id: string;

    constructor(data?: IQuestionTemplateSubCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionTemplateCategoryId = data["questionTemplateCategoryId"];
            this.questionTemplateCategoryName = data["questionTemplateCategoryName"];
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionTemplateSubCategoryDto {
        let result = new QuestionTemplateSubCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionTemplateCategoryId"] = this.questionTemplateCategoryId;
        data["questionTemplateCategoryName"] = this.questionTemplateCategoryName;
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionTemplateSubCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionTemplateSubCategoryDto {
    questionTemplateCategoryId: string;
    questionTemplateCategoryName: string;
    name: string;
    nameEn: string;
    id: string;
}

export class PagedResultDtoOfQuestionTemplateSubCategoryDto implements IPagedResultDtoOfQuestionTemplateSubCategoryDto {
    totalCount: number;
    items: QuestionTemplateSubCategoryDto[];

    constructor(data?: IPagedResultDtoOfQuestionTemplateSubCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionTemplateSubCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionTemplateSubCategoryDto {
        let result = new PagedResultDtoOfQuestionTemplateSubCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionTemplateSubCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionTemplateSubCategoryDto {
    totalCount: number;
    items: QuestionTemplateSubCategoryDto[];
}

export class QuestionTemplateValidationRuleDto implements IQuestionTemplateValidationRuleDto {
    questionTemplateId: string;
    questionTemplateName: string;
    ruleType: number;
    errorMessage: string;
    answers: string;
    id: string;

    constructor(data?: IQuestionTemplateValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionTemplateId = data["questionTemplateId"];
            this.questionTemplateName = data["questionTemplateName"];
            this.ruleType = data["ruleType"];
            this.errorMessage = data["errorMessage"];
            this.answers = data["answers"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionTemplateValidationRuleDto {
        let result = new QuestionTemplateValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionTemplateId"] = this.questionTemplateId;
        data["questionTemplateName"] = this.questionTemplateName;
        data["ruleType"] = this.ruleType;
        data["errorMessage"] = this.errorMessage;
        data["answers"] = this.answers;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new QuestionTemplateValidationRuleDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionTemplateValidationRuleDto {
    questionTemplateId: string;
    questionTemplateName: string;
    ruleType: number;
    errorMessage: string;
    answers: string;
    id: string;
}

export class PagedResultDtoOfQuestionTemplateValidationRuleDto implements IPagedResultDtoOfQuestionTemplateValidationRuleDto {
    totalCount: number;
    items: QuestionTemplateValidationRuleDto[];

    constructor(data?: IPagedResultDtoOfQuestionTemplateValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionTemplateValidationRuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuestionTemplateValidationRuleDto {
        let result = new PagedResultDtoOfQuestionTemplateValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfQuestionTemplateValidationRuleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfQuestionTemplateValidationRuleDto {
    totalCount: number;
    items: QuestionTemplateValidationRuleDto[];
}

export class RandomizedRegularDataByDomainDto implements IRandomizedRegularDataByDomainDto {
    domainCode: string;
    personsCount: number;
    sampleInterval: number;
    id: string;

    constructor(data?: IRandomizedRegularDataByDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainCode = data["domainCode"];
            this.personsCount = data["personsCount"];
            this.sampleInterval = data["sampleInterval"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RandomizedRegularDataByDomainDto {
        let result = new RandomizedRegularDataByDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainCode"] = this.domainCode;
        data["personsCount"] = this.personsCount;
        data["sampleInterval"] = this.sampleInterval;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RandomizedRegularDataByDomainDto();
        result.init(json);
        return result;
    }
}

export interface IRandomizedRegularDataByDomainDto {
    domainCode: string;
    personsCount: number;
    sampleInterval: number;
    id: string;
}

export class PagedResultDtoOfRandomizedRegularDataByDomainDto implements IPagedResultDtoOfRandomizedRegularDataByDomainDto {
    totalCount: number;
    items: RandomizedRegularDataByDomainDto[];

    constructor(data?: IPagedResultDtoOfRandomizedRegularDataByDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RandomizedRegularDataByDomainDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRandomizedRegularDataByDomainDto {
        let result = new PagedResultDtoOfRandomizedRegularDataByDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRandomizedRegularDataByDomainDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRandomizedRegularDataByDomainDto {
    totalCount: number;
    items: RandomizedRegularDataByDomainDto[];
}

export class RandomizedRegularDatumDto implements IRandomizedRegularDatumDto {
    minRange: number;
    maxRange: number;
    percentage: number;
    interval: number;
    id: number;

    constructor(data?: IRandomizedRegularDatumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.minRange = data["minRange"];
            this.maxRange = data["maxRange"];
            this.percentage = data["percentage"];
            this.interval = data["interval"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RandomizedRegularDatumDto {
        let result = new RandomizedRegularDatumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minRange"] = this.minRange;
        data["maxRange"] = this.maxRange;
        data["percentage"] = this.percentage;
        data["interval"] = this.interval;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RandomizedRegularDatumDto();
        result.init(json);
        return result;
    }
}

export interface IRandomizedRegularDatumDto {
    minRange: number;
    maxRange: number;
    percentage: number;
    interval: number;
    id: number;
}

export class PagedResultDtoOfRandomizedRegularDatumDto implements IPagedResultDtoOfRandomizedRegularDatumDto {
    totalCount: number;
    items: RandomizedRegularDatumDto[];

    constructor(data?: IPagedResultDtoOfRandomizedRegularDatumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RandomizedRegularDatumDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRandomizedRegularDatumDto {
        let result = new PagedResultDtoOfRandomizedRegularDatumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRandomizedRegularDatumDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRandomizedRegularDatumDto {
    totalCount: number;
    items: RandomizedRegularDatumDto[];
}

export class RegExDto implements IRegExDto {
    name: string;
    nameEn: string;
    regEx: string;
    categoryId: string;
    categoryName: string;
    id: string;

    constructor(data?: IRegExDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.regEx = data["regEx"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RegExDto {
        let result = new RegExDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["regEx"] = this.regEx;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegExDto();
        result.init(json);
        return result;
    }
}

export interface IRegExDto {
    name: string;
    nameEn: string;
    regEx: string;
    categoryId: string;
    categoryName: string;
    id: string;
}

export class PagedResultDtoOfRegExDto implements IPagedResultDtoOfRegExDto {
    totalCount: number;
    items: RegExDto[];

    constructor(data?: IPagedResultDtoOfRegExDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RegExDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRegExDto {
        let result = new PagedResultDtoOfRegExDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRegExDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRegExDto {
    totalCount: number;
    items: RegExDto[];
}

export class RegExCategoryDto implements IRegExCategoryDto {
    name: string;
    nameEn: string;
    id: string;

    constructor(data?: IRegExCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RegExCategoryDto {
        let result = new RegExCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegExCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IRegExCategoryDto {
    name: string;
    nameEn: string;
    id: string;
}

export class PagedResultDtoOfRegExCategoryDto implements IPagedResultDtoOfRegExCategoryDto {
    totalCount: number;
    items: RegExCategoryDto[];

    constructor(data?: IPagedResultDtoOfRegExCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RegExCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRegExCategoryDto {
        let result = new PagedResultDtoOfRegExCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRegExCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRegExCategoryDto {
    totalCount: number;
    items: RegExCategoryDto[];
}

export class ReportTypeDto implements IReportTypeDto {
    name: string;
    id: string;

    constructor(data?: IReportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ReportTypeDto {
        let result = new ReportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ReportTypeDto();
        result.init(json);
        return result;
    }
}

export interface IReportTypeDto {
    name: string;
    id: string;
}

export class PagedResultDtoOfReportTypeDto implements IPagedResultDtoOfReportTypeDto {
    totalCount: number;
    items: ReportTypeDto[];

    constructor(data?: IPagedResultDtoOfReportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ReportTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfReportTypeDto {
        let result = new PagedResultDtoOfReportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfReportTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfReportTypeDto {
    totalCount: number;
    items: ReportTypeDto[];
}

export class ResponseDto implements IResponseDto {
    surveyId: string;
    userId: string;
    dateSubmitted: moment.Moment;
    parentResponseId: string;
    startTime: moment.Moment;
    endTime: moment.Moment;
    code: string;
    domainId: string;
    status: number;
    subStatusId: string;
    title: string;
    order: number;
    lastUpdateTime: moment.Moment;
    isReal: boolean;
    isNew: boolean;
    subCode: string;
    phaseId: string;
    creationPhaseId: string;
    deletionPhaseId: string;
    gisUniqueCode: string;
    skipReason: number;
    skipComment: string;
    calledByCallCenter: number;
    callCenterComment: string;
    similarityPercentage: number;
    isPulled: boolean;
    codeToPartition: number;
    source: number;
    id: string;

    constructor(data?: IResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.surveyId = data["surveyId"];
            this.userId = data["userId"];
            this.dateSubmitted = data["dateSubmitted"] ? moment(data["dateSubmitted"].toString()) : <any>undefined;
            this.parentResponseId = data["parentResponseId"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.code = data["code"];
            this.domainId = data["domainId"];
            this.status = data["status"];
            this.subStatusId = data["subStatusId"];
            this.title = data["title"];
            this.order = data["order"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.isReal = data["isReal"];
            this.isNew = data["isNew"];
            this.subCode = data["subCode"];
            this.phaseId = data["phaseId"];
            this.creationPhaseId = data["creationPhaseId"];
            this.deletionPhaseId = data["deletionPhaseId"];
            this.gisUniqueCode = data["gisUniqueCode"];
            this.skipReason = data["skipReason"];
            this.skipComment = data["skipComment"];
            this.calledByCallCenter = data["calledByCallCenter"];
            this.callCenterComment = data["callCenterComment"];
            this.similarityPercentage = data["similarityPercentage"];
            this.isPulled = data["isPulled"];
            this.codeToPartition = data["codeToPartition"];
            this.source = data["source"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ResponseDto {
        let result = new ResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["userId"] = this.userId;
        data["dateSubmitted"] = this.dateSubmitted ? this.dateSubmitted.toISOString() : <any>undefined;
        data["parentResponseId"] = this.parentResponseId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["domainId"] = this.domainId;
        data["status"] = this.status;
        data["subStatusId"] = this.subStatusId;
        data["title"] = this.title;
        data["order"] = this.order;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["isReal"] = this.isReal;
        data["isNew"] = this.isNew;
        data["subCode"] = this.subCode;
        data["phaseId"] = this.phaseId;
        data["creationPhaseId"] = this.creationPhaseId;
        data["deletionPhaseId"] = this.deletionPhaseId;
        data["gisUniqueCode"] = this.gisUniqueCode;
        data["skipReason"] = this.skipReason;
        data["skipComment"] = this.skipComment;
        data["calledByCallCenter"] = this.calledByCallCenter;
        data["callCenterComment"] = this.callCenterComment;
        data["similarityPercentage"] = this.similarityPercentage;
        data["isPulled"] = this.isPulled;
        data["codeToPartition"] = this.codeToPartition;
        data["source"] = this.source;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResponseDto();
        result.init(json);
        return result;
    }
}

export interface IResponseDto {
    surveyId: string;
    userId: string;
    dateSubmitted: moment.Moment;
    parentResponseId: string;
    startTime: moment.Moment;
    endTime: moment.Moment;
    code: string;
    domainId: string;
    status: number;
    subStatusId: string;
    title: string;
    order: number;
    lastUpdateTime: moment.Moment;
    isReal: boolean;
    isNew: boolean;
    subCode: string;
    phaseId: string;
    creationPhaseId: string;
    deletionPhaseId: string;
    gisUniqueCode: string;
    skipReason: number;
    skipComment: string;
    calledByCallCenter: number;
    callCenterComment: string;
    similarityPercentage: number;
    isPulled: boolean;
    codeToPartition: number;
    source: number;
    id: string;
}

export class PagedResultDtoOfResponseDto implements IPagedResultDtoOfResponseDto {
    totalCount: number;
    items: ResponseDto[];

    constructor(data?: IPagedResultDtoOfResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfResponseDto {
        let result = new PagedResultDtoOfResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfResponseDto {
    totalCount: number;
    items: ResponseDto[];
}

export class ResponseSubStatusDto implements IResponseSubStatusDto {
    name: string;
    nameEn: string;
    id: string;

    constructor(data?: IResponseSubStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.nameEn = data["nameEn"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ResponseSubStatusDto {
        let result = new ResponseSubStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameEn"] = this.nameEn;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResponseSubStatusDto();
        result.init(json);
        return result;
    }
}

export interface IResponseSubStatusDto {
    name: string;
    nameEn: string;
    id: string;
}

export class PagedResultDtoOfResponseSubStatusDto implements IPagedResultDtoOfResponseSubStatusDto {
    totalCount: number;
    items: ResponseSubStatusDto[];

    constructor(data?: IPagedResultDtoOfResponseSubStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ResponseSubStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfResponseSubStatusDto {
        let result = new PagedResultDtoOfResponseSubStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfResponseSubStatusDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfResponseSubStatusDto {
    totalCount: number;
    items: ResponseSubStatusDto[];
}

export class SampleDto implements ISampleDto {
    createBy: string;
    assignedUserId: string;
    sampleSize: number;
    sampleDate: moment.Moment;
    properties: string;
    typeOfSample: string;
    id: string;

    constructor(data?: ISampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createBy = data["createBy"];
            this.assignedUserId = data["assignedUserId"];
            this.sampleSize = data["sampleSize"];
            this.sampleDate = data["sampleDate"] ? moment(data["sampleDate"].toString()) : <any>undefined;
            this.properties = data["properties"];
            this.typeOfSample = data["typeOfSample"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SampleDto {
        let result = new SampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createBy"] = this.createBy;
        data["assignedUserId"] = this.assignedUserId;
        data["sampleSize"] = this.sampleSize;
        data["sampleDate"] = this.sampleDate ? this.sampleDate.toISOString() : <any>undefined;
        data["properties"] = this.properties;
        data["typeOfSample"] = this.typeOfSample;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SampleDto();
        result.init(json);
        return result;
    }
}

export interface ISampleDto {
    createBy: string;
    assignedUserId: string;
    sampleSize: number;
    sampleDate: moment.Moment;
    properties: string;
    typeOfSample: string;
    id: string;
}

export class PagedResultDtoOfSampleDto implements IPagedResultDtoOfSampleDto {
    totalCount: number;
    items: SampleDto[];

    constructor(data?: IPagedResultDtoOfSampleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SampleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSampleDto {
        let result = new PagedResultDtoOfSampleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSampleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSampleDto {
    totalCount: number;
    items: SampleDto[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };
}

export class SimilarityDataByCallCenterDto implements ISimilarityDataByCallCenterDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    phaseId: string;
    surveyId: string;
    questionId: string;
    similarResponseAnswersCount: number;
    allResponseAnswersCount: number;
    id: string;

    constructor(data?: ISimilarityDataByCallCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainId = data["domainId"];
            this.parentDomainId = data["parentDomainId"];
            this.domainName = data["domainName"];
            this.domainCode = data["domainCode"];
            this.phaseId = data["phaseId"];
            this.surveyId = data["surveyId"];
            this.questionId = data["questionId"];
            this.similarResponseAnswersCount = data["similarResponseAnswersCount"];
            this.allResponseAnswersCount = data["allResponseAnswersCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SimilarityDataByCallCenterDto {
        let result = new SimilarityDataByCallCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainId"] = this.domainId;
        data["parentDomainId"] = this.parentDomainId;
        data["domainName"] = this.domainName;
        data["domainCode"] = this.domainCode;
        data["phaseId"] = this.phaseId;
        data["surveyId"] = this.surveyId;
        data["questionId"] = this.questionId;
        data["similarResponseAnswersCount"] = this.similarResponseAnswersCount;
        data["allResponseAnswersCount"] = this.allResponseAnswersCount;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SimilarityDataByCallCenterDto();
        result.init(json);
        return result;
    }
}

export interface ISimilarityDataByCallCenterDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    phaseId: string;
    surveyId: string;
    questionId: string;
    similarResponseAnswersCount: number;
    allResponseAnswersCount: number;
    id: string;
}

export class PagedResultDtoOfSimilarityDataByCallCenterDto implements IPagedResultDtoOfSimilarityDataByCallCenterDto {
    totalCount: number;
    items: SimilarityDataByCallCenterDto[];

    constructor(data?: IPagedResultDtoOfSimilarityDataByCallCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SimilarityDataByCallCenterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSimilarityDataByCallCenterDto {
        let result = new PagedResultDtoOfSimilarityDataByCallCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSimilarityDataByCallCenterDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSimilarityDataByCallCenterDto {
    totalCount: number;
    items: SimilarityDataByCallCenterDto[];
}

export class SimilarityDataByQualityDto implements ISimilarityDataByQualityDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    phaseId: string;
    surveyId: string;
    questionId: string;
    similarResponseAnswersCount: number;
    allResponseAnswersCount: number;
    id: string;

    constructor(data?: ISimilarityDataByQualityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainId = data["domainId"];
            this.parentDomainId = data["parentDomainId"];
            this.domainName = data["domainName"];
            this.domainCode = data["domainCode"];
            this.phaseId = data["phaseId"];
            this.surveyId = data["surveyId"];
            this.questionId = data["questionId"];
            this.similarResponseAnswersCount = data["similarResponseAnswersCount"];
            this.allResponseAnswersCount = data["allResponseAnswersCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SimilarityDataByQualityDto {
        let result = new SimilarityDataByQualityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainId"] = this.domainId;
        data["parentDomainId"] = this.parentDomainId;
        data["domainName"] = this.domainName;
        data["domainCode"] = this.domainCode;
        data["phaseId"] = this.phaseId;
        data["surveyId"] = this.surveyId;
        data["questionId"] = this.questionId;
        data["similarResponseAnswersCount"] = this.similarResponseAnswersCount;
        data["allResponseAnswersCount"] = this.allResponseAnswersCount;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SimilarityDataByQualityDto();
        result.init(json);
        return result;
    }
}

export interface ISimilarityDataByQualityDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    phaseId: string;
    surveyId: string;
    questionId: string;
    similarResponseAnswersCount: number;
    allResponseAnswersCount: number;
    id: string;
}

export class PagedResultDtoOfSimilarityDataByQualityDto implements IPagedResultDtoOfSimilarityDataByQualityDto {
    totalCount: number;
    items: SimilarityDataByQualityDto[];

    constructor(data?: IPagedResultDtoOfSimilarityDataByQualityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SimilarityDataByQualityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSimilarityDataByQualityDto {
        let result = new PagedResultDtoOfSimilarityDataByQualityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSimilarityDataByQualityDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSimilarityDataByQualityDto {
    totalCount: number;
    items: SimilarityDataByQualityDto[];
}

export class SimilarityPercentageDto implements ISimilarityPercentageDto {
    qualityParentResponseId: string;
    qualityResponseCode: string;
    realResponseId: string;
    realParentResponseId: string;
    realResponseCode: string;
    surveyId: string;
    similarResponseAnswersCount: number;
    allResponseAnswersCount: number;
    relationCode: number;
    typeCode: number;
    age: number;
    id: string;

    constructor(data?: ISimilarityPercentageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qualityParentResponseId = data["qualityParentResponseId"];
            this.qualityResponseCode = data["qualityResponseCode"];
            this.realResponseId = data["realResponseId"];
            this.realParentResponseId = data["realParentResponseId"];
            this.realResponseCode = data["realResponseCode"];
            this.surveyId = data["surveyId"];
            this.similarResponseAnswersCount = data["similarResponseAnswersCount"];
            this.allResponseAnswersCount = data["allResponseAnswersCount"];
            this.relationCode = data["relationCode"];
            this.typeCode = data["typeCode"];
            this.age = data["age"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SimilarityPercentageDto {
        let result = new SimilarityPercentageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qualityParentResponseId"] = this.qualityParentResponseId;
        data["qualityResponseCode"] = this.qualityResponseCode;
        data["realResponseId"] = this.realResponseId;
        data["realParentResponseId"] = this.realParentResponseId;
        data["realResponseCode"] = this.realResponseCode;
        data["surveyId"] = this.surveyId;
        data["similarResponseAnswersCount"] = this.similarResponseAnswersCount;
        data["allResponseAnswersCount"] = this.allResponseAnswersCount;
        data["relationCode"] = this.relationCode;
        data["typeCode"] = this.typeCode;
        data["age"] = this.age;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SimilarityPercentageDto();
        result.init(json);
        return result;
    }
}

export interface ISimilarityPercentageDto {
    qualityParentResponseId: string;
    qualityResponseCode: string;
    realResponseId: string;
    realParentResponseId: string;
    realResponseCode: string;
    surveyId: string;
    similarResponseAnswersCount: number;
    allResponseAnswersCount: number;
    relationCode: number;
    typeCode: number;
    age: number;
    id: string;
}

export class PagedResultDtoOfSimilarityPercentageDto implements IPagedResultDtoOfSimilarityPercentageDto {
    totalCount: number;
    items: SimilarityPercentageDto[];

    constructor(data?: IPagedResultDtoOfSimilarityPercentageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SimilarityPercentageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSimilarityPercentageDto {
        let result = new PagedResultDtoOfSimilarityPercentageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSimilarityPercentageDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSimilarityPercentageDto {
    totalCount: number;
    items: SimilarityPercentageDto[];
}

export class SurveyDto implements ISurveyDto {
    name: string;
    isActive: boolean;
    parentSurveyId: string;
    parentSurveyName: string;
    parentSurveyRelation: number;
    isEnabled: boolean;
    code: string;
    icon: string;
    allowAddResponse: boolean;
    typeText: string;
    serialDigitsCount: number;
    lastUpdateTime: moment.Moment;
    minMinutes: number;
    progressCalculationType: number;
    dailyTarget: number;
    isTemplate: boolean;
    id: string;

    constructor(data?: ISurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.parentSurveyId = data["parentSurveyId"];
            this.parentSurveyName = data["parentSurveyName"];
            this.parentSurveyRelation = data["parentSurveyRelation"];
            this.isEnabled = data["isEnabled"];
            this.code = data["code"];
            this.icon = data["icon"];
            this.allowAddResponse = data["allowAddResponse"];
            this.typeText = data["typeText"];
            this.serialDigitsCount = data["serialDigitsCount"];
            this.lastUpdateTime = data["lastUpdateTime"] ? moment(data["lastUpdateTime"].toString()) : <any>undefined;
            this.minMinutes = data["minMinutes"];
            this.progressCalculationType = data["progressCalculationType"];
            this.dailyTarget = data["dailyTarget"];
            this.isTemplate = data["isTemplate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SurveyDto {
        let result = new SurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["parentSurveyId"] = this.parentSurveyId;
        data["parentSurveyName"] = this.parentSurveyName;
        data["parentSurveyRelation"] = this.parentSurveyRelation;
        data["isEnabled"] = this.isEnabled;
        data["code"] = this.code;
        data["icon"] = this.icon;
        data["allowAddResponse"] = this.allowAddResponse;
        data["typeText"] = this.typeText;
        data["serialDigitsCount"] = this.serialDigitsCount;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        data["minMinutes"] = this.minMinutes;
        data["progressCalculationType"] = this.progressCalculationType;
        data["dailyTarget"] = this.dailyTarget;
        data["isTemplate"] = this.isTemplate;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SurveyDto();
        result.init(json);
        return result;
    }
}

export interface ISurveyDto {
    name: string;
    isActive: boolean;
    parentSurveyId: string;
    parentSurveyName: string;
    parentSurveyRelation: number;
    isEnabled: boolean;
    code: string;
    icon: string;
    allowAddResponse: boolean;
    typeText: string;
    serialDigitsCount: number;
    lastUpdateTime: moment.Moment;
    minMinutes: number;
    progressCalculationType: number;
    dailyTarget: number;
    isTemplate: boolean;
    id: string;
}

export class PagedResultDtoOfSurveyDto implements IPagedResultDtoOfSurveyDto {
    totalCount: number;
    items: SurveyDto[];

    constructor(data?: IPagedResultDtoOfSurveyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SurveyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSurveyDto {
        let result = new PagedResultDtoOfSurveyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSurveyDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSurveyDto {
    totalCount: number;
    items: SurveyDto[];
}

export class SyncLogDto implements ISyncLogDto {
    status: number;
    time: moment.Moment;
    isServer: boolean;
    count: number;
    userId: string;
    message: string;
    service: string;
    domainCode: string;
    arabicErrorDescription: string;
    id: string;

    constructor(data?: ISyncLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.time = data["time"] ? moment(data["time"].toString()) : <any>undefined;
            this.isServer = data["isServer"];
            this.count = data["count"];
            this.userId = data["userId"];
            this.message = data["message"];
            this.service = data["service"];
            this.domainCode = data["domainCode"];
            this.arabicErrorDescription = data["arabicErrorDescription"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SyncLogDto {
        let result = new SyncLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["isServer"] = this.isServer;
        data["count"] = this.count;
        data["userId"] = this.userId;
        data["message"] = this.message;
        data["service"] = this.service;
        data["domainCode"] = this.domainCode;
        data["arabicErrorDescription"] = this.arabicErrorDescription;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SyncLogDto();
        result.init(json);
        return result;
    }
}

export interface ISyncLogDto {
    status: number;
    time: moment.Moment;
    isServer: boolean;
    count: number;
    userId: string;
    message: string;
    service: string;
    domainCode: string;
    arabicErrorDescription: string;
    id: string;
}

export class PagedResultDtoOfSyncLogDto implements IPagedResultDtoOfSyncLogDto {
    totalCount: number;
    items: SyncLogDto[];

    constructor(data?: IPagedResultDtoOfSyncLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SyncLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSyncLogDto {
        let result = new PagedResultDtoOfSyncLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSyncLogDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSyncLogDto {
    totalCount: number;
    items: SyncLogDto[];
}

export class TempFilteredResponseDto implements ITempFilteredResponseDto {
    parentResponseId: string;
    code: string;
    rowIndex: number;
    id: string;

    constructor(data?: ITempFilteredResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentResponseId = data["parentResponseId"];
            this.code = data["code"];
            this.rowIndex = data["rowIndex"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TempFilteredResponseDto {
        let result = new TempFilteredResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentResponseId"] = this.parentResponseId;
        data["code"] = this.code;
        data["rowIndex"] = this.rowIndex;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TempFilteredResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITempFilteredResponseDto {
    parentResponseId: string;
    code: string;
    rowIndex: number;
    id: string;
}

export class PagedResultDtoOfTempFilteredResponseDto implements IPagedResultDtoOfTempFilteredResponseDto {
    totalCount: number;
    items: TempFilteredResponseDto[];

    constructor(data?: IPagedResultDtoOfTempFilteredResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TempFilteredResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTempFilteredResponseDto {
        let result = new PagedResultDtoOfTempFilteredResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTempFilteredResponseDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTempFilteredResponseDto {
    totalCount: number;
    items: TempFilteredResponseDto[];
}

export class TrainingAttendanceDto implements ITrainingAttendanceDto {
    time: moment.Moment;
    trainingMemberId: string;
    trainingMemberName: string;
    trainingProgramId: string;
    trainingProgramName: string;
    id: string;

    constructor(data?: ITrainingAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? moment(data["time"].toString()) : <any>undefined;
            this.trainingMemberId = data["trainingMemberId"];
            this.trainingMemberName = data["trainingMemberName"];
            this.trainingProgramId = data["trainingProgramId"];
            this.trainingProgramName = data["trainingProgramName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingAttendanceDto {
        let result = new TrainingAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["trainingMemberId"] = this.trainingMemberId;
        data["trainingMemberName"] = this.trainingMemberName;
        data["trainingProgramId"] = this.trainingProgramId;
        data["trainingProgramName"] = this.trainingProgramName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingAttendanceDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingAttendanceDto {
    time: moment.Moment;
    trainingMemberId: string;
    trainingMemberName: string;
    trainingProgramId: string;
    trainingProgramName: string;
    id: string;
}

export class PagedResultDtoOfTrainingAttendanceDto implements IPagedResultDtoOfTrainingAttendanceDto {
    totalCount: number;
    items: TrainingAttendanceDto[];

    constructor(data?: IPagedResultDtoOfTrainingAttendanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingAttendanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingAttendanceDto {
        let result = new PagedResultDtoOfTrainingAttendanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingAttendanceDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingAttendanceDto {
    totalCount: number;
    items: TrainingAttendanceDto[];
}

export class TrainingCenterDto implements ITrainingCenterDto {
    name: string;
    isActive: boolean;
    id: string;

    constructor(data?: ITrainingCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingCenterDto {
        let result = new TrainingCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingCenterDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingCenterDto {
    name: string;
    isActive: boolean;
    id: string;
}

export class PagedResultDtoOfTrainingCenterDto implements IPagedResultDtoOfTrainingCenterDto {
    totalCount: number;
    items: TrainingCenterDto[];

    constructor(data?: IPagedResultDtoOfTrainingCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingCenterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingCenterDto {
        let result = new PagedResultDtoOfTrainingCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingCenterDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingCenterDto {
    totalCount: number;
    items: TrainingCenterDto[];
}

export class TrainingCenterUserDto implements ITrainingCenterUserDto {
    userId: string;
    trainingCenterId: string;
    trainingCenterName: string;
    id: string;

    constructor(data?: ITrainingCenterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.trainingCenterId = data["trainingCenterId"];
            this.trainingCenterName = data["trainingCenterName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingCenterUserDto {
        let result = new TrainingCenterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["trainingCenterId"] = this.trainingCenterId;
        data["trainingCenterName"] = this.trainingCenterName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingCenterUserDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingCenterUserDto {
    userId: string;
    trainingCenterId: string;
    trainingCenterName: string;
    id: string;
}

export class PagedResultDtoOfTrainingCenterUserDto implements IPagedResultDtoOfTrainingCenterUserDto {
    totalCount: number;
    items: TrainingCenterUserDto[];

    constructor(data?: IPagedResultDtoOfTrainingCenterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingCenterUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingCenterUserDto {
        let result = new PagedResultDtoOfTrainingCenterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingCenterUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingCenterUserDto {
    totalCount: number;
    items: TrainingCenterUserDto[];
}

export class TrainingExamDto implements ITrainingExamDto {
    name: string;
    trainingProgramId: string;
    trainingProgramName: string;
    isActive: boolean;
    order: number;
    id: string;

    constructor(data?: ITrainingExamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.trainingProgramId = data["trainingProgramId"];
            this.trainingProgramName = data["trainingProgramName"];
            this.isActive = data["isActive"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingExamDto {
        let result = new TrainingExamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["trainingProgramId"] = this.trainingProgramId;
        data["trainingProgramName"] = this.trainingProgramName;
        data["isActive"] = this.isActive;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingExamDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingExamDto {
    name: string;
    trainingProgramId: string;
    trainingProgramName: string;
    isActive: boolean;
    order: number;
    id: string;
}

export class PagedResultDtoOfTrainingExamDto implements IPagedResultDtoOfTrainingExamDto {
    totalCount: number;
    items: TrainingExamDto[];

    constructor(data?: IPagedResultDtoOfTrainingExamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingExamDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingExamDto {
        let result = new PagedResultDtoOfTrainingExamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingExamDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingExamDto {
    totalCount: number;
    items: TrainingExamDto[];
}

export class TrainingMemberDto implements ITrainingMemberDto {
    name: string;
    age: number;
    telephone: string;
    email: string;
    nationalId: string;
    address: string;
    dateCreated: moment.Moment;
    createdById: string;
    trainingCenterId: string;
    trainingCenterName: string;
    trainingProgramId: string;
    trainingProgramName: string;
    id: string;

    constructor(data?: ITrainingMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.age = data["age"];
            this.telephone = data["telephone"];
            this.email = data["email"];
            this.nationalId = data["nationalId"];
            this.address = data["address"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.createdById = data["createdById"];
            this.trainingCenterId = data["trainingCenterId"];
            this.trainingCenterName = data["trainingCenterName"];
            this.trainingProgramId = data["trainingProgramId"];
            this.trainingProgramName = data["trainingProgramName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingMemberDto {
        let result = new TrainingMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["age"] = this.age;
        data["telephone"] = this.telephone;
        data["email"] = this.email;
        data["nationalId"] = this.nationalId;
        data["address"] = this.address;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["trainingCenterId"] = this.trainingCenterId;
        data["trainingCenterName"] = this.trainingCenterName;
        data["trainingProgramId"] = this.trainingProgramId;
        data["trainingProgramName"] = this.trainingProgramName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingMemberDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingMemberDto {
    name: string;
    age: number;
    telephone: string;
    email: string;
    nationalId: string;
    address: string;
    dateCreated: moment.Moment;
    createdById: string;
    trainingCenterId: string;
    trainingCenterName: string;
    trainingProgramId: string;
    trainingProgramName: string;
    id: string;
}

export class PagedResultDtoOfTrainingMemberDto implements IPagedResultDtoOfTrainingMemberDto {
    totalCount: number;
    items: TrainingMemberDto[];

    constructor(data?: IPagedResultDtoOfTrainingMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingMemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingMemberDto {
        let result = new PagedResultDtoOfTrainingMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingMemberDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingMemberDto {
    totalCount: number;
    items: TrainingMemberDto[];
}

export class TrainingProgramDto implements ITrainingProgramDto {
    name: string;
    from: moment.Moment;
    to: moment.Moment;
    phaseId: string;
    phaseName: string;
    isActive: boolean;
    attendanceTime: string;
    roleId: string;
    id: string;

    constructor(data?: ITrainingProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.isActive = data["isActive"];
            this.attendanceTime = data["attendanceTime"];
            this.roleId = data["roleId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingProgramDto {
        let result = new TrainingProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["isActive"] = this.isActive;
        data["attendanceTime"] = this.attendanceTime;
        data["roleId"] = this.roleId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingProgramDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingProgramDto {
    name: string;
    from: moment.Moment;
    to: moment.Moment;
    phaseId: string;
    phaseName: string;
    isActive: boolean;
    attendanceTime: string;
    roleId: string;
    id: string;
}

export class PagedResultDtoOfTrainingProgramDto implements IPagedResultDtoOfTrainingProgramDto {
    totalCount: number;
    items: TrainingProgramDto[];

    constructor(data?: IPagedResultDtoOfTrainingProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingProgramDto {
        let result = new PagedResultDtoOfTrainingProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingProgramDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingProgramDto {
    totalCount: number;
    items: TrainingProgramDto[];
}

export class TrainingProgramDocumentDto implements ITrainingProgramDocumentDto {
    trainingProgramId: string;
    trainingProgramName: string;
    name: string;
    file: string;
    id: string;

    constructor(data?: ITrainingProgramDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingProgramId = data["trainingProgramId"];
            this.trainingProgramName = data["trainingProgramName"];
            this.name = data["name"];
            this.file = data["file"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingProgramDocumentDto {
        let result = new TrainingProgramDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingProgramId"] = this.trainingProgramId;
        data["trainingProgramName"] = this.trainingProgramName;
        data["name"] = this.name;
        data["file"] = this.file;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingProgramDocumentDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingProgramDocumentDto {
    trainingProgramId: string;
    trainingProgramName: string;
    name: string;
    file: string;
    id: string;
}

export class PagedResultDtoOfTrainingProgramDocumentDto implements IPagedResultDtoOfTrainingProgramDocumentDto {
    totalCount: number;
    items: TrainingProgramDocumentDto[];

    constructor(data?: IPagedResultDtoOfTrainingProgramDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingProgramDocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingProgramDocumentDto {
        let result = new PagedResultDtoOfTrainingProgramDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingProgramDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingProgramDocumentDto {
    totalCount: number;
    items: TrainingProgramDocumentDto[];
}

export class TrainingResultDto implements ITrainingResultDto {
    trainingMemberId: string;
    trainingMemberName: string;
    trainingExamId: string;
    trainingExamName: string;
    score: number;
    id: string;

    constructor(data?: ITrainingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingMemberId = data["trainingMemberId"];
            this.trainingMemberName = data["trainingMemberName"];
            this.trainingExamId = data["trainingExamId"];
            this.trainingExamName = data["trainingExamName"];
            this.score = data["score"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TrainingResultDto {
        let result = new TrainingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingMemberId"] = this.trainingMemberId;
        data["trainingMemberName"] = this.trainingMemberName;
        data["trainingExamId"] = this.trainingExamId;
        data["trainingExamName"] = this.trainingExamName;
        data["score"] = this.score;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TrainingResultDto();
        result.init(json);
        return result;
    }
}

export interface ITrainingResultDto {
    trainingMemberId: string;
    trainingMemberName: string;
    trainingExamId: string;
    trainingExamName: string;
    score: number;
    id: string;
}

export class PagedResultDtoOfTrainingResultDto implements IPagedResultDtoOfTrainingResultDto {
    totalCount: number;
    items: TrainingResultDto[];

    constructor(data?: IPagedResultDtoOfTrainingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TrainingResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTrainingResultDto {
        let result = new PagedResultDtoOfTrainingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTrainingResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTrainingResultDto {
    totalCount: number;
    items: TrainingResultDto[];
}

export class IFormFile implements IIFormFile {
    contentType: string;
    contentDisposition: string;
    headers: { [key: string] : string[]; };
    length: number;
    name: string;
    fileName: string;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["contentType"];
            this.contentDisposition = data["contentDisposition"];
            if (data["headers"]) {
                this.headers = {};
                for (let key in data["headers"]) {
                    if (data["headers"].hasOwnProperty(key))
                        this.headers[key] = data["headers"][key];
                }
            }
            this.length = data["length"];
            this.name = data["name"];
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): IFormFile {
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["contentDisposition"] = this.contentDisposition;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["length"] = this.length;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IFormFile();
        result.init(json);
        return result;
    }
}

export interface IIFormFile {
    contentType: string;
    contentDisposition: string;
    headers: { [key: string] : string[]; };
    length: number;
    name: string;
    fileName: string;
}

export class UploadedReportDto implements IUploadedReportDto {
    name: string;
    reportTypeId: string;
    reportTypeName: string;
    domainId: string;
    domainName: string;
    rating: number;
    file: string;
    createdDate: moment.Moment;
    createdBy: string;
    phaseId: string;
    phaseName: string;
    id: string;

    constructor(data?: IUploadedReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.reportTypeId = data["reportTypeId"];
            this.reportTypeName = data["reportTypeName"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.rating = data["rating"];
            this.file = data["file"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.phaseId = data["phaseId"];
            this.phaseName = data["phaseName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UploadedReportDto {
        let result = new UploadedReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["reportTypeId"] = this.reportTypeId;
        data["reportTypeName"] = this.reportTypeName;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["rating"] = this.rating;
        data["file"] = this.file;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["phaseId"] = this.phaseId;
        data["phaseName"] = this.phaseName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UploadedReportDto();
        result.init(json);
        return result;
    }
}

export interface IUploadedReportDto {
    name: string;
    reportTypeId: string;
    reportTypeName: string;
    domainId: string;
    domainName: string;
    rating: number;
    file: string;
    createdDate: moment.Moment;
    createdBy: string;
    phaseId: string;
    phaseName: string;
    id: string;
}

export class PagedResultDtoOfUploadedReportDto implements IPagedResultDtoOfUploadedReportDto {
    totalCount: number;
    items: UploadedReportDto[];

    constructor(data?: IPagedResultDtoOfUploadedReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UploadedReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUploadedReportDto {
        let result = new PagedResultDtoOfUploadedReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUploadedReportDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUploadedReportDto {
    totalCount: number;
    items: UploadedReportDto[];
}

export class UploadedReportRoleDto implements IUploadedReportRoleDto {
    uploadedReportId: string;
    uploadedReportName: string;
    roleId: string;
    id: string;

    constructor(data?: IUploadedReportRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uploadedReportId = data["uploadedReportId"];
            this.uploadedReportName = data["uploadedReportName"];
            this.roleId = data["roleId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UploadedReportRoleDto {
        let result = new UploadedReportRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploadedReportId"] = this.uploadedReportId;
        data["uploadedReportName"] = this.uploadedReportName;
        data["roleId"] = this.roleId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UploadedReportRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUploadedReportRoleDto {
    uploadedReportId: string;
    uploadedReportName: string;
    roleId: string;
    id: string;
}

export class PagedResultDtoOfUploadedReportRoleDto implements IPagedResultDtoOfUploadedReportRoleDto {
    totalCount: number;
    items: UploadedReportRoleDto[];

    constructor(data?: IPagedResultDtoOfUploadedReportRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UploadedReportRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUploadedReportRoleDto {
        let result = new PagedResultDtoOfUploadedReportRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUploadedReportRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUploadedReportRoleDto {
    totalCount: number;
    items: UploadedReportRoleDto[];
}

export class UserApplicationDto implements IUserApplicationDto {
    applicationId: string;
    applicationName: string;
    userId: string;
    id: string;

    constructor(data?: IUserApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applicationId = data["applicationId"];
            this.applicationName = data["applicationName"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserApplicationDto {
        let result = new UserApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["applicationName"] = this.applicationName;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserApplicationDto();
        result.init(json);
        return result;
    }
}

export interface IUserApplicationDto {
    applicationId: string;
    applicationName: string;
    userId: string;
    id: string;
}

export class PagedResultDtoOfUserApplicationDto implements IPagedResultDtoOfUserApplicationDto {
    totalCount: number;
    items: UserApplicationDto[];

    constructor(data?: IPagedResultDtoOfUserApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserApplicationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserApplicationDto {
        let result = new PagedResultDtoOfUserApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserApplicationDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserApplicationDto {
    totalCount: number;
    items: UserApplicationDto[];
}

export class UserDomainDto implements IUserDomainDto {
    userId: string;
    domainId: string;
    domainName: string;
    applicationId: string;
    applicationName: string;
    id: string;

    constructor(data?: IUserDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.domainId = data["domainId"];
            this.domainName = data["domainName"];
            this.applicationId = data["applicationId"];
            this.applicationName = data["applicationName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDomainDto {
        let result = new UserDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["domainId"] = this.domainId;
        data["domainName"] = this.domainName;
        data["applicationId"] = this.applicationId;
        data["applicationName"] = this.applicationName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserDomainDto();
        result.init(json);
        return result;
    }
}

export interface IUserDomainDto {
    userId: string;
    domainId: string;
    domainName: string;
    applicationId: string;
    applicationName: string;
    id: string;
}

export class PagedResultDtoOfUserDomainDto implements IPagedResultDtoOfUserDomainDto {
    totalCount: number;
    items: UserDomainDto[];

    constructor(data?: IPagedResultDtoOfUserDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDomainDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDomainDto {
        let result = new PagedResultDtoOfUserDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDomainDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDomainDto {
    totalCount: number;
    items: UserDomainDto[];
}

export class UserLocationByDomainDto implements IUserLocationByDomainDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    inAreaLocationCount: number;
    outOfAreaLocationCount: number;
    unavailableAreaLocationCount: number;
    id: string;

    constructor(data?: IUserLocationByDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainId = data["domainId"];
            this.parentDomainId = data["parentDomainId"];
            this.domainName = data["domainName"];
            this.domainCode = data["domainCode"];
            this.inAreaLocationCount = data["inAreaLocationCount"];
            this.outOfAreaLocationCount = data["outOfAreaLocationCount"];
            this.unavailableAreaLocationCount = data["unavailableAreaLocationCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLocationByDomainDto {
        let result = new UserLocationByDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainId"] = this.domainId;
        data["parentDomainId"] = this.parentDomainId;
        data["domainName"] = this.domainName;
        data["domainCode"] = this.domainCode;
        data["inAreaLocationCount"] = this.inAreaLocationCount;
        data["outOfAreaLocationCount"] = this.outOfAreaLocationCount;
        data["unavailableAreaLocationCount"] = this.unavailableAreaLocationCount;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLocationByDomainDto();
        result.init(json);
        return result;
    }
}

export interface IUserLocationByDomainDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    inAreaLocationCount: number;
    outOfAreaLocationCount: number;
    unavailableAreaLocationCount: number;
    id: string;
}

export class PagedResultDtoOfUserLocationByDomainDto implements IPagedResultDtoOfUserLocationByDomainDto {
    totalCount: number;
    items: UserLocationByDomainDto[];

    constructor(data?: IPagedResultDtoOfUserLocationByDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLocationByDomainDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserLocationByDomainDto {
        let result = new PagedResultDtoOfUserLocationByDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserLocationByDomainDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserLocationByDomainDto {
    totalCount: number;
    items: UserLocationByDomainDto[];
}

export class UserLocationByDomainsHistoryDto implements IUserLocationByDomainsHistoryDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    inAreaLocationCount: number;
    outOfAreaLocationCount: number;
    unavailableAreaLocationCount: number;
    date: moment.Moment;
    id: string;

    constructor(data?: IUserLocationByDomainsHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainId = data["domainId"];
            this.parentDomainId = data["parentDomainId"];
            this.domainName = data["domainName"];
            this.domainCode = data["domainCode"];
            this.inAreaLocationCount = data["inAreaLocationCount"];
            this.outOfAreaLocationCount = data["outOfAreaLocationCount"];
            this.unavailableAreaLocationCount = data["unavailableAreaLocationCount"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLocationByDomainsHistoryDto {
        let result = new UserLocationByDomainsHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainId"] = this.domainId;
        data["parentDomainId"] = this.parentDomainId;
        data["domainName"] = this.domainName;
        data["domainCode"] = this.domainCode;
        data["inAreaLocationCount"] = this.inAreaLocationCount;
        data["outOfAreaLocationCount"] = this.outOfAreaLocationCount;
        data["unavailableAreaLocationCount"] = this.unavailableAreaLocationCount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLocationByDomainsHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IUserLocationByDomainsHistoryDto {
    domainId: string;
    parentDomainId: string;
    domainName: string;
    domainCode: string;
    inAreaLocationCount: number;
    outOfAreaLocationCount: number;
    unavailableAreaLocationCount: number;
    date: moment.Moment;
    id: string;
}

export class PagedResultDtoOfUserLocationByDomainsHistoryDto implements IPagedResultDtoOfUserLocationByDomainsHistoryDto {
    totalCount: number;
    items: UserLocationByDomainsHistoryDto[];

    constructor(data?: IPagedResultDtoOfUserLocationByDomainsHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLocationByDomainsHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserLocationByDomainsHistoryDto {
        let result = new PagedResultDtoOfUserLocationByDomainsHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserLocationByDomainsHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserLocationByDomainsHistoryDto {
    totalCount: number;
    items: UserLocationByDomainsHistoryDto[];
}

export class UserProfileDto implements IUserProfileDto {
    userId: string;
    fullName: string;
    nationalId: string;
    contractType: number;
    paymentNumber: string;
    bankName: number;
    bankAccount: string;
    isActive: boolean;
    createdDate: moment.Moment;
    id: string;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.fullName = data["fullName"];
            this.nationalId = data["nationalId"];
            this.contractType = data["contractType"];
            this.paymentNumber = data["paymentNumber"];
            this.bankName = data["bankName"];
            this.bankAccount = data["bankAccount"];
            this.isActive = data["isActive"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserProfileDto {
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["nationalId"] = this.nationalId;
        data["contractType"] = this.contractType;
        data["paymentNumber"] = this.paymentNumber;
        data["bankName"] = this.bankName;
        data["bankAccount"] = this.bankAccount;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUserProfileDto {
    userId: string;
    fullName: string;
    nationalId: string;
    contractType: number;
    paymentNumber: string;
    bankName: number;
    bankAccount: string;
    isActive: boolean;
    createdDate: moment.Moment;
    id: string;
}

export class PagedResultDtoOfUserProfileDto implements IPagedResultDtoOfUserProfileDto {
    totalCount: number;
    items: UserProfileDto[];

    constructor(data?: IPagedResultDtoOfUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserProfileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserProfileDto {
        let result = new PagedResultDtoOfUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserProfileDto {
    totalCount: number;
    items: UserProfileDto[];
}

export class UserProfilesProgressDto implements IUserProfilesProgressDto {
    userProfileId: string;
    isActive: boolean;
    userId: string;
    userName: string;
    userCode: string;
    managerId: string;
    surveyId: string;
    count: number;
    creationPhaseId: string;
    id: string;

    constructor(data?: IUserProfilesProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userProfileId = data["userProfileId"];
            this.isActive = data["isActive"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userCode = data["userCode"];
            this.managerId = data["managerId"];
            this.surveyId = data["surveyId"];
            this.count = data["count"];
            this.creationPhaseId = data["creationPhaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserProfilesProgressDto {
        let result = new UserProfilesProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userProfileId"] = this.userProfileId;
        data["isActive"] = this.isActive;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userCode"] = this.userCode;
        data["managerId"] = this.managerId;
        data["surveyId"] = this.surveyId;
        data["count"] = this.count;
        data["creationPhaseId"] = this.creationPhaseId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserProfilesProgressDto();
        result.init(json);
        return result;
    }
}

export interface IUserProfilesProgressDto {
    userProfileId: string;
    isActive: boolean;
    userId: string;
    userName: string;
    userCode: string;
    managerId: string;
    surveyId: string;
    count: number;
    creationPhaseId: string;
    id: string;
}

export class PagedResultDtoOfUserProfilesProgressDto implements IPagedResultDtoOfUserProfilesProgressDto {
    totalCount: number;
    items: UserProfilesProgressDto[];

    constructor(data?: IPagedResultDtoOfUserProfilesProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserProfilesProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserProfilesProgressDto {
        let result = new PagedResultDtoOfUserProfilesProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserProfilesProgressDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserProfilesProgressDto {
    totalCount: number;
    items: UserProfilesProgressDto[];
}

export class UsersActiveDomainDto implements IUsersActiveDomainDto {
    userId: string;
    activeDomainId: string;
    id: string;

    constructor(data?: IUsersActiveDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.activeDomainId = data["activeDomainId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UsersActiveDomainDto {
        let result = new UsersActiveDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["activeDomainId"] = this.activeDomainId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UsersActiveDomainDto();
        result.init(json);
        return result;
    }
}

export interface IUsersActiveDomainDto {
    userId: string;
    activeDomainId: string;
    id: string;
}

export class PagedResultDtoOfUsersActiveDomainDto implements IPagedResultDtoOfUsersActiveDomainDto {
    totalCount: number;
    items: UsersActiveDomainDto[];

    constructor(data?: IPagedResultDtoOfUsersActiveDomainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UsersActiveDomainDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUsersActiveDomainDto {
        let result = new PagedResultDtoOfUsersActiveDomainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUsersActiveDomainDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUsersActiveDomainDto {
    totalCount: number;
    items: UsersActiveDomainDto[];
}

export class UsersAssignmentDto implements IUsersAssignmentDto {
    domainCode: string;
    from: string;
    fromActual: string;
    to: string;
    toActual: string;
    userCode: string;
    validInput: boolean;
    invalidError: string;
    isValid: boolean;
    lastUpdatedUser: string;
    id: number;

    constructor(data?: IUsersAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.domainCode = data["domainCode"];
            this.from = data["from"];
            this.fromActual = data["fromActual"];
            this.to = data["to"];
            this.toActual = data["toActual"];
            this.userCode = data["userCode"];
            this.validInput = data["validInput"];
            this.invalidError = data["invalidError"];
            this.isValid = data["isValid"];
            this.lastUpdatedUser = data["lastUpdatedUser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UsersAssignmentDto {
        let result = new UsersAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domainCode"] = this.domainCode;
        data["from"] = this.from;
        data["fromActual"] = this.fromActual;
        data["to"] = this.to;
        data["toActual"] = this.toActual;
        data["userCode"] = this.userCode;
        data["validInput"] = this.validInput;
        data["invalidError"] = this.invalidError;
        data["isValid"] = this.isValid;
        data["lastUpdatedUser"] = this.lastUpdatedUser;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UsersAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IUsersAssignmentDto {
    domainCode: string;
    from: string;
    fromActual: string;
    to: string;
    toActual: string;
    userCode: string;
    validInput: boolean;
    invalidError: string;
    isValid: boolean;
    lastUpdatedUser: string;
    id: number;
}

export class PagedResultDtoOfUsersAssignmentDto implements IPagedResultDtoOfUsersAssignmentDto {
    totalCount: number;
    items: UsersAssignmentDto[];

    constructor(data?: IPagedResultDtoOfUsersAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UsersAssignmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUsersAssignmentDto {
        let result = new PagedResultDtoOfUsersAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUsersAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUsersAssignmentDto {
    totalCount: number;
    items: UsersAssignmentDto[];
}

export class UserSurveysTemplateDto implements IUserSurveysTemplateDto {
    surveyId: string;
    surveyName: string;
    userId: string;
    id: string;

    constructor(data?: IUserSurveysTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.surveyId = data["surveyId"];
            this.surveyName = data["surveyName"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserSurveysTemplateDto {
        let result = new UserSurveysTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyId"] = this.surveyId;
        data["surveyName"] = this.surveyName;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserSurveysTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IUserSurveysTemplateDto {
    surveyId: string;
    surveyName: string;
    userId: string;
    id: string;
}

export class PagedResultDtoOfUserSurveysTemplateDto implements IPagedResultDtoOfUserSurveysTemplateDto {
    totalCount: number;
    items: UserSurveysTemplateDto[];

    constructor(data?: IPagedResultDtoOfUserSurveysTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserSurveysTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserSurveysTemplateDto {
        let result = new PagedResultDtoOfUserSurveysTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserSurveysTemplateDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserSurveysTemplateDto {
    totalCount: number;
    items: UserSurveysTemplateDto[];
}

export class ValidationDto implements IValidationDto {
    name: string;
    displayName: string;
    validationTypes: ValidationTypes[];

    constructor(data?: IValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            if (data["validationTypes"] && data["validationTypes"].constructor === Array) {
                this.validationTypes = [];
                for (let item of data["validationTypes"])
                    this.validationTypes.push(ValidationTypes.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationDto {
        let result = new ValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        if (this.validationTypes && this.validationTypes.constructor === Array) {
            data["validationTypes"] = [];
            for (let item of this.validationTypes)
                data["validationTypes"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ValidationDto();
        result.init(json);
        return result;
    }
}

export interface IValidationDto {
    name: string;
    displayName: string;
    validationTypes: ValidationTypes[];
}

export class ValidationTypes implements IValidationTypes {
    validationName: string;
    errorMessage: string;
    minLength: number;
    maxLength: number;

    constructor(data?: IValidationTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.validationName = data["validationName"];
            this.errorMessage = data["errorMessage"];
            this.minLength = data["minLength"];
            this.maxLength = data["maxLength"];
        }
    }

    static fromJS(data: any): ValidationTypes {
        let result = new ValidationTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validationName"] = this.validationName;
        data["errorMessage"] = this.errorMessage;
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ValidationTypes();
        result.init(json);
        return result;
    }
}

export interface IValidationTypes {
    validationName: string;
    errorMessage: string;
    minLength: number;
    maxLength: number;
}

export class ViolatedValidationRuleDto implements IViolatedValidationRuleDto {
    responseAnswerId: string;
    validationRuleId: string;
    responseId: string;
    id: string;

    constructor(data?: IViolatedValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.responseAnswerId = data["responseAnswerId"];
            this.validationRuleId = data["validationRuleId"];
            this.responseId = data["responseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ViolatedValidationRuleDto {
        let result = new ViolatedValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseAnswerId"] = this.responseAnswerId;
        data["validationRuleId"] = this.validationRuleId;
        data["responseId"] = this.responseId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ViolatedValidationRuleDto();
        result.init(json);
        return result;
    }
}

export interface IViolatedValidationRuleDto {
    responseAnswerId: string;
    validationRuleId: string;
    responseId: string;
    id: string;
}

export class PagedResultDtoOfViolatedValidationRuleDto implements IPagedResultDtoOfViolatedValidationRuleDto {
    totalCount: number;
    items: ViolatedValidationRuleDto[];

    constructor(data?: IPagedResultDtoOfViolatedValidationRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ViolatedValidationRuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfViolatedValidationRuleDto {
        let result = new PagedResultDtoOfViolatedValidationRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfViolatedValidationRuleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfViolatedValidationRuleDto {
    totalCount: number;
    items: ViolatedValidationRuleDto[];
}

export class WorkingDataByUserDto implements IWorkingDataByUserDto {
    userId: string;
    userName: string;
    userCode: string;
    managerId: string;
    completedSurveys: number;
    workingHours: number;
    date: moment.Moment;
    phaseId: string;
    id: string;

    constructor(data?: IWorkingDataByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userCode = data["userCode"];
            this.managerId = data["managerId"];
            this.completedSurveys = data["completedSurveys"];
            this.workingHours = data["workingHours"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.phaseId = data["phaseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkingDataByUserDto {
        let result = new WorkingDataByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userCode"] = this.userCode;
        data["managerId"] = this.managerId;
        data["completedSurveys"] = this.completedSurveys;
        data["workingHours"] = this.workingHours;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["phaseId"] = this.phaseId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WorkingDataByUserDto();
        result.init(json);
        return result;
    }
}

export interface IWorkingDataByUserDto {
    userId: string;
    userName: string;
    userCode: string;
    managerId: string;
    completedSurveys: number;
    workingHours: number;
    date: moment.Moment;
    phaseId: string;
    id: string;
}

export class PagedResultDtoOfWorkingDataByUserDto implements IPagedResultDtoOfWorkingDataByUserDto {
    totalCount: number;
    items: WorkingDataByUserDto[];

    constructor(data?: IPagedResultDtoOfWorkingDataByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WorkingDataByUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkingDataByUserDto {
        let result = new PagedResultDtoOfWorkingDataByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWorkingDataByUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWorkingDataByUserDto {
    totalCount: number;
    items: WorkingDataByUserDto[];
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}